diff --git a/codex-rs/app-server-protocol/src/bin/export.rs b/codex-rs/app-server-protocol/src/bin/export.rs
index d029ecbf..c70ad507 100644
--- a/codex-rs/app-server-protocol/src/bin/export.rs
+++ b/codex-rs/app-server-protocol/src/bin/export.rs
@@ -1,6 +1,6 @@
 use anyhow::Result;
 use clap::Parser;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Parser, Debug)]
 #[command(
diff --git a/codex-rs/app-server-protocol/src/export.rs b/codex-rs/app-server-protocol/src/export.rs
index 11296e8e..3edbd6ce 100644
--- a/codex-rs/app-server-protocol/src/export.rs
+++ b/codex-rs/app-server-protocol/src/export.rs
@@ -20,13 +20,64 @@ use serde::Serialize;
 use serde_json::Map;
 use serde_json::Value;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::collections::HashSet;
 use std::ffi::OsStr;
 use std::fs;
 use std::io::Read;
 use std::io::Write;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process::Command;
 use ts_rs::TS;
 
@@ -704,7 +755,7 @@ mod tests {
     use anyhow::Result;
     use std::collections::BTreeSet;
     use std::fs;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use uuid::Uuid;
 
     #[test]
diff --git a/codex-rs/app-server-protocol/src/protocol/common.rs b/codex-rs/app-server-protocol/src/protocol/common.rs
index db9bed11..64a20d7f 100644
--- a/codex-rs/app-server-protocol/src/protocol/common.rs
+++ b/codex-rs/app-server-protocol/src/protocol/common.rs
@@ -517,7 +517,7 @@ mod tests {
     use codex_protocol::protocol::AskForApproval;
     use pretty_assertions::assert_eq;
     use serde_json::json;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
 
     #[test]
     fn serialize_new_conversation() -> Result<()> {
diff --git a/codex-rs/app-server-protocol/src/protocol/v1.rs b/codex-rs/app-server-protocol/src/protocol/v1.rs
index 54f80c9f..d5122b21 100644
--- a/codex-rs/app-server-protocol/src/protocol/v1.rs
+++ b/codex-rs/app-server-protocol/src/protocol/v1.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 use codex_protocol::ConversationId;
 use codex_protocol::config_types::ForcedLoginMethod;
diff --git a/codex-rs/app-server-protocol/src/protocol/v2.rs b/codex-rs/app-server-protocol/src/protocol/v2.rs
index a2b9cee3..d5c4de84 100644
--- a/codex-rs/app-server-protocol/src/protocol/v2.rs
+++ b/codex-rs/app-server-protocol/src/protocol/v2.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 use crate::protocol::common::AuthMode;
 use codex_protocol::ConversationId;
@@ -981,7 +1032,7 @@ mod tests {
     use codex_protocol::items::WebSearchItem;
     use codex_protocol::user_input::UserInput as CoreUserInput;
     use pretty_assertions::assert_eq;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
 
     #[test]
     fn core_turn_item_into_thread_item_converts_supported_variants() {
diff --git a/codex-rs/app-server/src/bespoke_event_handling.rs b/codex-rs/app-server/src/bespoke_event_handling.rs
index 8ed343f0..9c81f4fa 100644
--- a/codex-rs/app-server/src/bespoke_event_handling.rs
+++ b/codex-rs/app-server/src/bespoke_event_handling.rs
@@ -40,7 +40,7 @@ use codex_core::protocol::Op;
 use codex_core::protocol::ReviewDecision;
 use codex_protocol::ConversationId;
 use std::convert::TryFrom;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use tokio::sync::oneshot;
 use tracing::error;
 
diff --git a/codex-rs/app-server/src/codex_message_processor.rs b/codex-rs/app-server/src/codex_message_processor.rs
index c5ac6a14..489d5e99 100644
--- a/codex-rs/app-server/src/codex_message_processor.rs
+++ b/codex-rs/app-server/src/codex_message_processor.rs
@@ -132,11 +132,62 @@ use codex_protocol::protocol::USER_MESSAGE_BEGIN;
 use codex_protocol::user_input::UserInput as CoreInputItem;
 use codex_utils_json_to_toml::json_to_toml;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::ffi::OsStr;
 use std::io::Error as IoError;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicBool;
 use std::sync::atomic::Ordering;
 use std::time::Duration;
@@ -146,6 +197,52 @@ use tokio::sync::oneshot;
 use tracing::error;
 use tracing::info;
 use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use uuid::Uuid;
 
 type PendingInterruptQueue = Vec<(RequestId, ApiVersion)>;
diff --git a/codex-rs/app-server/src/fuzzy_file_search.rs b/codex-rs/app-server/src/fuzzy_file_search.rs
index fcb05852..8ed93f08 100644
--- a/codex-rs/app-server/src/fuzzy_file_search.rs
+++ b/codex-rs/app-server/src/fuzzy_file_search.rs
@@ -1,8 +1,8 @@
 use std::num::NonZero;
 use std::num::NonZeroUsize;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicBool;
 
 use codex_app_server_protocol::FuzzyFileSearchResult;
@@ -10,6 +10,52 @@ use codex_file_search as file_search;
 use tokio::task::JoinSet;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 const LIMIT_PER_ROOT: usize = 50;
 const MAX_THREADS: usize = 12;
 const COMPUTE_INDICES: bool = true;
diff --git a/codex-rs/app-server/src/lib.rs b/codex-rs/app-server/src/lib.rs
index 4b65e66d..77b4f99b 100644
--- a/codex-rs/app-server/src/lib.rs
+++ b/codex-rs/app-server/src/lib.rs
@@ -6,7 +6,7 @@ use codex_core::config::ConfigOverrides;
 use opentelemetry_appender_tracing::layer::OpenTelemetryTracingBridge;
 use std::io::ErrorKind;
 use std::io::Result as IoResult;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::message_processor::MessageProcessor;
 use crate::outgoing_message::OutgoingMessage;
diff --git a/codex-rs/app-server/src/message_processor.rs b/codex-rs/app-server/src/message_processor.rs
index a97b037b..8140ef95 100644
--- a/codex-rs/app-server/src/message_processor.rs
+++ b/codex-rs/app-server/src/message_processor.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::codex_message_processor::CodexMessageProcessor;
 use crate::error_code::INVALID_REQUEST_ERROR_CODE;
@@ -19,7 +19,7 @@ use codex_core::default_client::USER_AGENT_SUFFIX;
 use codex_core::default_client::get_codex_user_agent;
 use codex_feedback::CodexFeedback;
 use codex_protocol::protocol::SessionSource;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 pub(crate) struct MessageProcessor {
     outgoing: Arc<OutgoingMessageSender>,
diff --git a/codex-rs/app-server/src/outgoing_message.rs b/codex-rs/app-server/src/outgoing_message.rs
index f0ee6cf9..ae609918 100644
--- a/codex-rs/app-server/src/outgoing_message.rs
+++ b/codex-rs/app-server/src/outgoing_message.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::sync::atomic::AtomicI64;
 use std::sync::atomic::Ordering;
 
@@ -14,6 +65,52 @@ use tokio::sync::mpsc;
 use tokio::sync::oneshot;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::error_code::INTERNAL_ERROR_CODE;
 
 /// Sends messages to the client and manages request callbacks.
diff --git a/codex-rs/app-server/tests/common/rollout.rs b/codex-rs/app-server/tests/common/rollout.rs
index c8197a04..fd30d330 100644
--- a/codex-rs/app-server/tests/common/rollout.rs
+++ b/codex-rs/app-server/tests/common/rollout.rs
@@ -5,7 +5,7 @@ use codex_protocol::protocol::SessionSource;
 use serde_json::json;
 use std::fs;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use uuid::Uuid;
 
 /// Create a minimal rollout file under `CODEX_HOME/sessions/YYYY/MM/DD/`.
diff --git a/codex-rs/app-server/tests/suite/config.rs b/codex-rs/app-server/tests/suite/config.rs
index 281d5492..2b37c517 100644
--- a/codex-rs/app-server/tests/suite/config.rs
+++ b/codex-rs/app-server/tests/suite/config.rs
@@ -16,6 +16,57 @@ use codex_protocol::config_types::SandboxMode;
 use codex_protocol::config_types::Verbosity;
 use pretty_assertions::assert_eq;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
 use tempfile::TempDir;
 use tokio::time::timeout;
diff --git a/codex-rs/apply-patch/src/lib.rs b/codex-rs/apply-patch/src/lib.rs
index ac2f4097..b8ca0e9d 100644
--- a/codex-rs/apply-patch/src/lib.rs
+++ b/codex-rs/apply-patch/src/lib.rs
@@ -3,8 +3,59 @@ mod seek_sequence;
 mod standalone_executable;
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::str::Utf8Error;
 use std::sync::LazyLock;
 
diff --git a/codex-rs/apply-patch/src/parser.rs b/codex-rs/apply-patch/src/parser.rs
index 768c89ad..727c9234 100644
--- a/codex-rs/apply-patch/src/parser.rs
+++ b/codex-rs/apply-patch/src/parser.rs
@@ -24,7 +24,7 @@
 //! leading/trailing whitespace around patch markers.
 use crate::ApplyPatchArgs;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use thiserror::Error;
 
diff --git a/codex-rs/arg0/src/lib.rs b/codex-rs/arg0/src/lib.rs
index 6b605364..7624a268 100644
--- a/codex-rs/arg0/src/lib.rs
+++ b/codex-rs/arg0/src/lib.rs
@@ -1,6 +1,6 @@
 use std::future::Future;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::CODEX_APPLY_PATCH_ARG1;
 #[cfg(unix)]
diff --git a/codex-rs/backend-client/src/types.rs b/codex-rs/backend-client/src/types.rs
index 9f196f9c..29b620db 100644
--- a/codex-rs/backend-client/src/types.rs
+++ b/codex-rs/backend-client/src/types.rs
@@ -9,6 +9,57 @@ use serde::Deserialize;
 use serde::de::Deserializer;
 use serde_json::Value;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 /// Hand-rolled models for the Cloud Tasks task-details response.
 /// The generated OpenAPI models are pretty bad. This is a half-step
diff --git a/codex-rs/chatgpt/src/apply_command.rs b/codex-rs/chatgpt/src/apply_command.rs
index ffd460e2..4eafafea 100644
--- a/codex-rs/chatgpt/src/apply_command.rs
+++ b/codex-rs/chatgpt/src/apply_command.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use clap::Parser;
 use codex_common::CliConfigOverrides;
diff --git a/codex-rs/cli/src/debug_sandbox.rs b/codex-rs/cli/src/debug_sandbox.rs
index df4c2e97..f440776f 100644
--- a/codex-rs/cli/src/debug_sandbox.rs
+++ b/codex-rs/cli/src/debug_sandbox.rs
@@ -3,7 +3,7 @@ mod pid_tracker;
 #[cfg(target_os = "macos")]
 mod seatbelt;
 
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_common::CliConfigOverrides;
 use codex_core::config::Config;
diff --git a/codex-rs/cli/src/debug_sandbox/pid_tracker.rs b/codex-rs/cli/src/debug_sandbox/pid_tracker.rs
index 07bd2fd0..9cd0cf3d 100644
--- a/codex-rs/cli/src/debug_sandbox/pid_tracker.rs
+++ b/codex-rs/cli/src/debug_sandbox/pid_tracker.rs
@@ -2,6 +2,52 @@ use std::collections::HashSet;
 use tokio::task::JoinHandle;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 /// Tracks the (recursive) descendants of a process by using `kqueue` to watch for fork events, and
 /// `proc_listchildpids` to list the children of a process.
 pub(crate) struct PidTracker {
diff --git a/codex-rs/cli/src/login.rs b/codex-rs/cli/src/login.rs
index 6681ab20..9e2bcbe6 100644
--- a/codex-rs/cli/src/login.rs
+++ b/codex-rs/cli/src/login.rs
@@ -13,7 +13,7 @@ use codex_login::run_login_server;
 use codex_protocol::config_types::ForcedLoginMethod;
 use std::io::IsTerminal;
 use std::io::Read;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 pub async fn login_with_chatgpt(
     codex_home: PathBuf,
diff --git a/codex-rs/cli/src/main.rs b/codex-rs/cli/src/main.rs
index 6a3b24aa..9543fe01 100644
--- a/codex-rs/cli/src/main.rs
+++ b/codex-rs/cli/src/main.rs
@@ -23,7 +23,7 @@ use codex_tui::AppExitInfo;
 use codex_tui::Cli as TuiCli;
 use codex_tui::update_action::UpdateAction;
 use owo_colors::OwoColorize;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use supports_color::Stream;
 
 mod mcp_cmd;
diff --git a/codex-rs/cli/src/mcp_cmd.rs b/codex-rs/cli/src/mcp_cmd.rs
index ec37c3a6..cee63359 100644
--- a/codex-rs/cli/src/mcp_cmd.rs
+++ b/codex-rs/cli/src/mcp_cmd.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 use anyhow::Context;
 use anyhow::Result;
diff --git a/codex-rs/cloud-tasks-client/src/http.rs b/codex-rs/cloud-tasks-client/src/http.rs
index 57d39b7b..41685367 100644
--- a/codex-rs/cloud-tasks-client/src/http.rs
+++ b/codex-rs/cloud-tasks-client/src/http.rs
@@ -114,6 +114,57 @@ mod api {
     use serde_json::Value;
     use std::cmp::Ordering;
     use std::collections::HashMap;
+    use std::env;
+    use std::fs::OpenOptions;
+    use std::io::Write;
+    use serde_json::json;
+    use tracing::warn;
+    
+    static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+    
+    fn event_trace_path() -> Option<&'static PathBuf> {
+        EVENT_TRACE_PATH
+            .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                Some(path) if !path.is_empty() => {
+                    let file = PathBuf::from(path);
+                    if let Some(parent) = file.parent() {
+                        if let Err(err) = std::fs::create_dir_all(parent) {
+                            warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                            return None;
+                        }
+                    }
+                    Some(file)
+                }
+                _ => None,
+            })
+            .as_ref()
+    }
+    
+    fn log_event_for_hypebrut(event: &Event) {
+        let Some(path) = event_trace_path() else {
+            return;
+        };
+    
+        let timestamp = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_default()
+            .as_secs_f64();
+    
+        let payload = serde_json::json!({
+            \"ts\": timestamp,
+            \"event\": event,
+        });
+    
+        if let Err(err) = append_event_line(path, payload.to_string()) {
+            warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+        }
+    }
+    
+    fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+        let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+        file.write_all(line.as_bytes())?;
+        file.write_all(b\"\\n\")
+    }
 
     pub(crate) struct Tasks<'a> {
         base_url: &'a str,
diff --git a/codex-rs/cloud-tasks/src/app.rs b/codex-rs/cloud-tasks/src/app.rs
index 612c5f6b..b78409d3 100644
--- a/codex-rs/cloud-tasks/src/app.rs
+++ b/codex-rs/cloud-tasks/src/app.rs
@@ -1,4 +1,5 @@
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 // Environment filter data models for the TUI
diff --git a/codex-rs/cloud-tasks/src/env_detect.rs b/codex-rs/cloud-tasks/src/env_detect.rs
index e7e8fb6b..5a12b0ed 100644
--- a/codex-rs/cloud-tasks/src/env_detect.rs
+++ b/codex-rs/cloud-tasks/src/env_detect.rs
@@ -1,9 +1,106 @@
 use reqwest::header::CONTENT_TYPE;
 use reqwest::header::HeaderMap;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use tracing::info;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 #[derive(Debug, Clone, serde::Deserialize)]
 struct CodeEnvironment {
     id: String,
diff --git a/codex-rs/cloud-tasks/src/lib.rs b/codex-rs/cloud-tasks/src/lib.rs
index 6fc72140..5cdae684 100644
--- a/codex-rs/cloud-tasks/src/lib.rs
+++ b/codex-rs/cloud-tasks/src/lib.rs
@@ -11,9 +11,10 @@ use anyhow::anyhow;
 use codex_login::AuthManager;
 use std::io::IsTerminal;
 use std::io::Read;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 use tokio::sync::mpsc::UnboundedSender;
 use tracing::info;
@@ -452,6 +453,7 @@ pub async fn run_main(cli: Cli, _codex_linux_sandbox_exe: Option<PathBuf>) -> an
 
     // Event-driven redraws with a tiny coalescing scheduler (snappy UI, no fixed 250ms tick).
     let mut needs_redraw = true;
+    use std::sync::OnceLock;
     use std::time::Instant;
     use tokio::time::Instant as TokioInstant;
     use tokio::time::sleep_until;
diff --git a/codex-rs/cloud-tasks/src/ui.rs b/codex-rs/cloud-tasks/src/ui.rs
index e3a97aeb..fa564b61 100644
--- a/codex-rs/cloud-tasks/src/ui.rs
+++ b/codex-rs/cloud-tasks/src/ui.rs
@@ -16,6 +16,7 @@ use ratatui::widgets::ListState;
 use ratatui::widgets::Padding;
 use ratatui::widgets::Paragraph;
 use std::sync::OnceLock;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use crate::app::App;
diff --git a/codex-rs/common/src/elapsed.rs b/codex-rs/common/src/elapsed.rs
index 297832b1..35957edd 100644
--- a/codex-rs/common/src/elapsed.rs
+++ b/codex-rs/common/src/elapsed.rs
@@ -1,4 +1,5 @@
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 /// Returns a string representing the elapsed time since `start_time` like
diff --git a/codex-rs/common/src/format_env_display.rs b/codex-rs/common/src/format_env_display.rs
index fa35bdce..28cc06d9 100644
--- a/codex-rs/common/src/format_env_display.rs
+++ b/codex-rs/common/src/format_env_display.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 pub fn format_env_display(env: Option<&HashMap<String, String>>, env_vars: &[String]) -> String {
     let mut parts: Vec<String> = Vec::new();
diff --git a/codex-rs/common/src/model_presets.rs b/codex-rs/common/src/model_presets.rs
index 9921f969..8f7b4afc 100644
--- a/codex-rs/common/src/model_presets.rs
+++ b/codex-rs/common/src/model_presets.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 use codex_app_server_protocol::AuthMode;
 use codex_core::protocol_config_types::ReasoningEffort;
diff --git a/codex-rs/core/src/apply_patch.rs b/codex-rs/core/src/apply_patch.rs
index dffe94be..7c00a60f 100644
--- a/codex-rs/core/src/apply_patch.rs
+++ b/codex-rs/core/src/apply_patch.rs
@@ -8,7 +8,58 @@ use crate::safety::assess_patch_safety;
 use codex_apply_patch::ApplyPatchAction;
 use codex_apply_patch::ApplyPatchFileChange;
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 pub const CODEX_APPLY_PATCH_ARG1: &str = "--codex-run-as-apply-patch";
 
diff --git a/codex-rs/core/src/auth.rs b/codex-rs/core/src/auth.rs
index d874435e..acd2ab0c 100644
--- a/codex-rs/core/src/auth.rs
+++ b/codex-rs/core/src/auth.rs
@@ -10,8 +10,8 @@ use std::env;
 use std::fmt::Debug;
 use std::io::ErrorKind;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::Mutex;
 use std::time::Duration;
 
diff --git a/codex-rs/core/src/auth/storage.rs b/codex-rs/core/src/auth/storage.rs
index a238eb9c..b392745b 100644
--- a/codex-rs/core/src/auth/storage.rs
+++ b/codex-rs/core/src/auth/storage.rs
@@ -12,10 +12,56 @@ use std::io::Write;
 #[cfg(unix)]
 use std::os::unix::fs::OpenOptionsExt;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::token_data::TokenData;
 use codex_keyring_store::DefaultKeyringStore;
 use codex_keyring_store::KeyringStore;
diff --git a/codex-rs/core/src/bash.rs b/codex-rs/core/src/bash.rs
index 0ffb8e78..eacb3996 100644
--- a/codex-rs/core/src/bash.rs
+++ b/codex-rs/core/src/bash.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use tree_sitter::Node;
 use tree_sitter::Parser;
diff --git a/codex-rs/core/src/client.rs b/codex-rs/core/src/client.rs
index 46144586..2a2d4647 100644
--- a/codex-rs/core/src/client.rs
+++ b/codex-rs/core/src/client.rs
@@ -1,6 +1,6 @@
 use std::io::BufRead;
 use std::path::Path;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::OnceLock;
 use std::time::Duration;
 
@@ -29,6 +29,52 @@ use tracing::debug;
 use tracing::trace;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::AuthManager;
 use crate::auth::CodexAuth;
 use crate::auth::RefreshTokenError;
diff --git a/codex-rs/core/src/codex.rs b/codex-rs/core/src/codex.rs
index 31961768..b90a5bc1 100644
--- a/codex-rs/core/src/codex.rs
+++ b/codex-rs/core/src/codex.rs
@@ -1,8 +1,63 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::fmt::Debug;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicU64;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use std::time::{SystemTime, UNIX_EPOCH};
 
 use crate::AuthManager;
 use crate::client_common::REVIEW_PROMPT;
@@ -51,6 +106,52 @@ use tracing::error;
 use tracing::info;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::ModelProviderInfo;
 use crate::client::ModelClient;
 use crate::client_common::Prompt;
@@ -200,6 +301,15 @@ impl Codex {
             CodexErr::InternalAgentDied
         })?;
         let conversation_id = session.conversation_id;
+        
+        for event in config_notices {
+            tx_event
+                .send(event)
+                .await
+                .map_err(|_| CodexErr::InternalAgentDied)?;
+        }
+        
+        // This task will run until Op::Shutdown is received.
 
         // This task will run until Op::Shutdown is received.
         tokio::spawn(submission_loop(session, config, rx_sub));
@@ -710,12 +820,24 @@ impl Session {
         sub_id: String,
         updates: SessionSettingsUpdate,
     ) -> Arc<TurnContext> {
-        let session_configuration = {
+        let auth_snapshot = self.services.auth_manager.auth();
+        let (session_configuration, override_notice) = {
             let mut state = self.state.lock().await;
-            let session_configuration = state.session_configuration.clone().apply(&updates);
+            let mut session_configuration = state.session_configuration.clone().apply(&updates);
+            let override_notice = maybe_override_chatgpt_model(&mut session_configuration.model, auth_snapshot.clone());
             state.session_configuration = session_configuration.clone();
-            session_configuration
+            (session_configuration, override_notice)
         };
+        if let Some(notice) = override_notice {
+            let _ = self
+                .tx_event
+                .send(Event {
+                    id: INITIAL_SUBMIT_ID.to_owned(),
+                    msg: EventMsg::DeprecationNotice(notice),
+                })
+                .await;
+        }
+        
 
         let mut turn_context: TurnContext = Self::make_turn_context(
             Some(Arc::clone(&self.services.auth_manager)),
@@ -1416,9 +1538,55 @@ mod handlers {
     use codex_protocol::protocol::ReviewRequest;
     use codex_protocol::protocol::TurnAbortReason;
     use codex_protocol::user_input::UserInput;
-    use std::sync::Arc;
+    use std::sync::{Arc, OnceLock};
     use tracing::info;
     use tracing::warn;
+    
+    static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+    
+    fn event_trace_path() -> Option<&'static PathBuf> {
+        EVENT_TRACE_PATH
+            .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                Some(path) if !path.is_empty() => {
+                    let file = PathBuf::from(path);
+                    if let Some(parent) = file.parent() {
+                        if let Err(err) = std::fs::create_dir_all(parent) {
+                            warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                            return None;
+                        }
+                    }
+                    Some(file)
+                }
+                _ => None,
+            })
+            .as_ref()
+    }
+    
+    fn log_event_for_hypebrut(event: &Event) {
+        let Some(path) = event_trace_path() else {
+            return;
+        };
+    
+        let timestamp = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_default()
+            .as_secs_f64();
+    
+        let payload = serde_json::json!({
+            \"ts\": timestamp,
+            \"event\": event,
+        });
+    
+        if let Err(err) = append_event_line(path, payload.to_string()) {
+            warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+        }
+    }
+    
+    fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+        let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+        file.write_all(line.as_bytes())?;
+        file.write_all(b\"\\n\")
+    }
 
     pub async fn interrupt(sess: &Arc<Session>) {
         sess.interrupt_task().await;
@@ -2347,8 +2515,8 @@ mod tests {
     use pretty_assertions::assert_eq;
     use serde::Deserialize;
     use serde_json::json;
-    use std::path::PathBuf;
-    use std::sync::Arc;
+    use std::path::{Path, PathBuf};
+    use std::sync::{Arc, OnceLock};
     use std::time::Duration as StdDuration;
 
     #[test]
@@ -2969,6 +3137,57 @@ mod tests {
         use crate::protocol::SandboxPolicy;
         use crate::turn_diff_tracker::TurnDiffTracker;
         use std::collections::HashMap;
+        use std::env;
+        use std::fs::OpenOptions;
+        use std::io::Write;
+        use serde_json::json;
+        use tracing::warn;
+        
+        static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+        
+        fn event_trace_path() -> Option<&'static PathBuf> {
+            EVENT_TRACE_PATH
+                .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                    Some(path) if !path.is_empty() => {
+                        let file = PathBuf::from(path);
+                        if let Some(parent) = file.parent() {
+                            if let Err(err) = std::fs::create_dir_all(parent) {
+                                warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                                return None;
+                            }
+                        }
+                        Some(file)
+                    }
+                    _ => None,
+                })
+                .as_ref()
+        }
+        
+        fn log_event_for_hypebrut(event: &Event) {
+            let Some(path) = event_trace_path() else {
+                return;
+            };
+        
+            let timestamp = SystemTime::now()
+                .duration_since(UNIX_EPOCH)
+                .unwrap_or_default()
+                .as_secs_f64();
+        
+            let payload = serde_json::json!({
+                \"ts\": timestamp,
+                \"event\": event,
+            });
+        
+            if let Err(err) = append_event_line(path, payload.to_string()) {
+                warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+            }
+        }
+        
+        fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+            let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+            file.write_all(line.as_bytes())?;
+            file.write_all(b\"\\n\")
+        }
 
         let (session, mut turn_context_raw) = make_session_and_context();
         // Ensure policy is NOT OnRequest so the early rejection path triggers
diff --git a/codex-rs/core/src/codex_conversation.rs b/codex-rs/core/src/codex_conversation.rs
index 5bb9c97c..30b24871 100644
--- a/codex-rs/core/src/codex_conversation.rs
+++ b/codex-rs/core/src/codex_conversation.rs
@@ -3,7 +3,7 @@ use crate::error::Result as CodexResult;
 use crate::protocol::Event;
 use crate::protocol::Op;
 use crate::protocol::Submission;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 pub struct CodexConversation {
     codex: Codex,
diff --git a/codex-rs/core/src/codex_delegate.rs b/codex-rs/core/src/codex_delegate.rs
index 4cb4d4a0..ee98558e 100644
--- a/codex-rs/core/src/codex_delegate.rs
+++ b/codex-rs/core/src/codex_delegate.rs
@@ -1,5 +1,9 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicU64;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use std::time::{SystemTime, UNIX_EPOCH};
 
 use async_channel::Receiver;
 use async_channel::Sender;
diff --git a/codex-rs/core/src/compact.rs b/codex-rs/core/src/compact.rs
index 6908faee..d88ed270 100644
--- a/codex-rs/core/src/compact.rs
+++ b/codex-rs/core/src/compact.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use crate::Prompt;
 use crate::client_common::ResponseEvent;
diff --git a/codex-rs/core/src/config/edit.rs b/codex-rs/core/src/config/edit.rs
index 2d58ffc6..b6324ae7 100644
--- a/codex-rs/core/src/config/edit.rs
+++ b/codex-rs/core/src/config/edit.rs
@@ -7,7 +7,7 @@ use codex_protocol::config_types::TrustLevel;
 use codex_utils_tokenizer::warm_model_cache;
 use std::collections::BTreeMap;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tempfile::NamedTempFile;
 use tokio::task;
 use toml_edit::DocumentMut;
diff --git a/codex-rs/core/src/config/mod.rs b/codex-rs/core/src/config/mod.rs
index 5b57d4dc..4adb4e3a 100644
--- a/codex-rs/core/src/config/mod.rs
+++ b/codex-rs/core/src/config/mod.rs
@@ -49,9 +49,60 @@ use serde::Deserialize;
 use similar::DiffableStr;
 use std::collections::BTreeMap;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::io::ErrorKind;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::config::profile::ConfigProfile;
 use toml::Value as TomlValue;
diff --git a/codex-rs/core/src/config/profile.rs b/codex-rs/core/src/config/profile.rs
index 3d9e60b8..6145f331 100644
--- a/codex-rs/core/src/config/profile.rs
+++ b/codex-rs/core/src/config/profile.rs
@@ -1,5 +1,5 @@
 use serde::Deserialize;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::protocol::AskForApproval;
 use codex_protocol::config_types::ReasoningEffort;
diff --git a/codex-rs/core/src/config/types.rs b/codex-rs/core/src/config/types.rs
index 9c2cd03d..4ae28963 100644
--- a/codex-rs/core/src/config/types.rs
+++ b/codex-rs/core/src/config/types.rs
@@ -5,7 +5,58 @@
 
 use serde::Deserializer;
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 use std::time::Duration;
 use wildmatch::WildMatchPattern;
 
diff --git a/codex-rs/core/src/config_loader/mod.rs b/codex-rs/core/src/config_loader/mod.rs
index 6b55b015..be4ecdbd 100644
--- a/codex-rs/core/src/config_loader/mod.rs
+++ b/codex-rs/core/src/config_loader/mod.rs
@@ -4,7 +4,7 @@ use crate::config::CONFIG_TOML_FILE;
 use macos::load_managed_admin_config_layer;
 use std::io;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tokio::fs;
 use toml::Value as TomlValue;
 
diff --git a/codex-rs/core/src/conversation_manager.rs b/codex-rs/core/src/conversation_manager.rs
index 8ffefd56..ab8f402e 100644
--- a/codex-rs/core/src/conversation_manager.rs
+++ b/codex-rs/core/src/conversation_manager.rs
@@ -18,8 +18,59 @@ use codex_protocol::protocol::InitialHistory;
 use codex_protocol::protocol::RolloutItem;
 use codex_protocol::protocol::SessionSource;
 use std::collections::HashMap;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use tokio::sync::RwLock;
 
 /// Represents a newly created Codex conversation, including the first event
diff --git a/codex-rs/core/src/custom_prompts.rs b/codex-rs/core/src/custom_prompts.rs
index 66b2bab3..220ac0a2 100644
--- a/codex-rs/core/src/custom_prompts.rs
+++ b/codex-rs/core/src/custom_prompts.rs
@@ -1,7 +1,7 @@
 use codex_protocol::custom_prompts::CustomPrompt;
 use std::collections::HashSet;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tokio::fs;
 
 /// Return the default prompts directory: `$CODEX_HOME/prompts`.
diff --git a/codex-rs/core/src/default_client.rs b/codex-rs/core/src/default_client.rs
index 8e463546..0ee49bd7 100644
--- a/codex-rs/core/src/default_client.rs
+++ b/codex-rs/core/src/default_client.rs
@@ -7,6 +7,57 @@ use reqwest::header::HeaderName;
 use reqwest::header::HeaderValue;
 use serde::Serialize;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::fmt::Display;
 use std::sync::LazyLock;
 use std::sync::Mutex;
diff --git a/codex-rs/core/src/environment_context.rs b/codex-rs/core/src/environment_context.rs
index 6db2bb8f..9153426e 100644
--- a/codex-rs/core/src/environment_context.rs
+++ b/codex-rs/core/src/environment_context.rs
@@ -11,7 +11,7 @@ use codex_protocol::models::ContentItem;
 use codex_protocol::models::ResponseItem;
 use codex_protocol::protocol::ENVIRONMENT_CONTEXT_CLOSE_TAG;
 use codex_protocol::protocol::ENVIRONMENT_CONTEXT_OPEN_TAG;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, DeriveDisplay)]
 #[serde(rename_all = "kebab-case")]
diff --git a/codex-rs/core/src/event_mapping.rs b/codex-rs/core/src/event_mapping.rs
index d0aa1d81..b579882f 100644
--- a/codex-rs/core/src/event_mapping.rs
+++ b/codex-rs/core/src/event_mapping.rs
@@ -11,6 +11,52 @@ use codex_protocol::models::ResponseItem;
 use codex_protocol::models::WebSearchAction;
 use codex_protocol::user_input::UserInput;
 use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use uuid::Uuid;
 
 use crate::user_instructions::UserInstructions;
diff --git a/codex-rs/core/src/exec.rs b/codex-rs/core/src/exec.rs
index b44a40bd..79c62b02 100644
--- a/codex-rs/core/src/exec.rs
+++ b/codex-rs/core/src/exec.rs
@@ -2,11 +2,63 @@
 use std::os::unix::process::ExitStatusExt;
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::io;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process::ExitStatus;
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use async_channel::Sender;
diff --git a/codex-rs/core/src/exec_env.rs b/codex-rs/core/src/exec_env.rs
index 11334896..4b4b84f8 100644
--- a/codex-rs/core/src/exec_env.rs
+++ b/codex-rs/core/src/exec_env.rs
@@ -2,6 +2,57 @@ use crate::config::types::EnvironmentVariablePattern;
 use crate::config::types::ShellEnvironmentPolicy;
 use crate::config::types::ShellEnvironmentPolicyInherit;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::collections::HashSet;
 
 /// Construct an environment map based on the rules in the specified policy. The
diff --git a/codex-rs/core/src/git_info.rs b/codex-rs/core/src/git_info.rs
index 387e9a68..d69a4223 100644
--- a/codex-rs/core/src/git_info.rs
+++ b/codex-rs/core/src/git_info.rs
@@ -1,6 +1,6 @@
 use std::collections::HashSet;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_app_server_protocol::GitSha;
 use codex_protocol::protocol::GitInfo;
@@ -601,7 +601,7 @@ mod tests {
 
     use core_test_support::skip_if_sandbox;
     use std::fs;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use tempfile::TempDir;
 
     // Helper function to create a test git repository
diff --git a/codex-rs/core/src/landlock.rs b/codex-rs/core/src/landlock.rs
index 340aebff..01a73015 100644
--- a/codex-rs/core/src/landlock.rs
+++ b/codex-rs/core/src/landlock.rs
@@ -2,8 +2,59 @@ use crate::protocol::SandboxPolicy;
 use crate::spawn::StdioPolicy;
 use crate::spawn::spawn_child_async;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tokio::process::Child;
 
 /// Spawn a shell tool command under the Linux Landlock+seccomp sandbox helper
diff --git a/codex-rs/core/src/mcp/auth.rs b/codex-rs/core/src/mcp/auth.rs
index e321a857..8ae97be1 100644
--- a/codex-rs/core/src/mcp/auth.rs
+++ b/codex-rs/core/src/mcp/auth.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 use anyhow::Result;
 use codex_protocol::protocol::McpAuthStatus;
@@ -7,6 +58,52 @@ use codex_rmcp_client::determine_streamable_http_auth_status;
 use futures::future::join_all;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::config::types::McpServerConfig;
 use crate::config::types::McpServerTransportConfig;
 
diff --git a/codex-rs/core/src/mcp_connection_manager.rs b/codex-rs/core/src/mcp_connection_manager.rs
index d8869e5e..df426e97 100644
--- a/codex-rs/core/src/mcp_connection_manager.rs
+++ b/codex-rs/core/src/mcp_connection_manager.rs
@@ -7,10 +7,61 @@
 //! `"<server><MCP_TOOL_NAME_DELIMITER><tool>"` as the key.
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::collections::HashSet;
 use std::env;
 use std::ffi::OsString;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use crate::mcp::auth::McpAuthStatusEntry;
@@ -50,6 +101,52 @@ use tokio::task::JoinSet;
 use tokio_util::sync::CancellationToken;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::codex::INITIAL_SUBMIT_ID;
 use crate::config::types::McpServerConfig;
 use crate::config::types::McpServerTransportConfig;
diff --git a/codex-rs/core/src/mcp_tool_call.rs b/codex-rs/core/src/mcp_tool_call.rs
index 51664103..d03d049b 100644
--- a/codex-rs/core/src/mcp_tool_call.rs
+++ b/codex-rs/core/src/mcp_tool_call.rs
@@ -1,3 +1,4 @@
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use tracing::error;
diff --git a/codex-rs/core/src/message_history.rs b/codex-rs/core/src/message_history.rs
index e96d8d50..99b12368 100644
--- a/codex-rs/core/src/message_history.rs
+++ b/codex-rs/core/src/message_history.rs
@@ -18,7 +18,7 @@ use std::fs::File;
 use std::fs::OpenOptions;
 use std::io::Result;
 use std::io::Write;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use serde::Deserialize;
 use serde::Serialize;
diff --git a/codex-rs/core/src/model_provider_info.rs b/codex-rs/core/src/model_provider_info.rs
index 6aa7a31d..7690ff7e 100644
--- a/codex-rs/core/src/model_provider_info.rs
+++ b/codex-rs/core/src/model_provider_info.rs
@@ -12,6 +12,57 @@ use codex_app_server_protocol::AuthMode;
 use serde::Deserialize;
 use serde::Serialize;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::env::VarError;
 use std::time::Duration;
 
diff --git a/codex-rs/core/src/parse_command.rs b/codex-rs/core/src/parse_command.rs
index f9819ba8..ff768f0f 100644
--- a/codex-rs/core/src/parse_command.rs
+++ b/codex-rs/core/src/parse_command.rs
@@ -4,7 +4,7 @@ use crate::bash::try_parse_word_only_commands_sequence;
 use codex_protocol::parse_command::ParsedCommand;
 use shlex::split as shlex_split;
 use shlex::try_join as shlex_try_join;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 pub fn shlex_join(tokens: &[String]) -> String {
     shlex_try_join(tokens.iter().map(String::as_str))
@@ -39,7 +39,7 @@ pub fn parse_command(command: &[String]) -> Vec<ParsedCommand> {
 /// Tests are at the top to encourage using TDD + Codex to fix the implementation.
 mod tests {
     use super::*;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use std::string::ToString;
 
     fn shlex_split_safe(s: &str) -> Vec<String> {
diff --git a/codex-rs/core/src/project_doc.rs b/codex-rs/core/src/project_doc.rs
index c8076aa8..04cbf7f8 100644
--- a/codex-rs/core/src/project_doc.rs
+++ b/codex-rs/core/src/project_doc.rs
@@ -15,7 +15,7 @@
 
 use crate::config::Config;
 use dunce::canonicalize as normalize_path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tokio::io::AsyncReadExt;
 use tracing::error;
 
diff --git a/codex-rs/core/src/response_processing.rs b/codex-rs/core/src/response_processing.rs
index 458f8252..d180bd4a 100644
--- a/codex-rs/core/src/response_processing.rs
+++ b/codex-rs/core/src/response_processing.rs
@@ -5,6 +5,52 @@ use codex_protocol::models::ResponseInputItem;
 use codex_protocol::models::ResponseItem;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 /// Process streamed `ResponseItem`s from the model into the pair of:
 /// - items we should record in conversation history; and
 /// - `ResponseInputItem`s to send back to the model on the next turn.
diff --git a/codex-rs/core/src/rollout/list.rs b/codex-rs/core/src/rollout/list.rs
index 781e3fe3..4089bae4 100644
--- a/codex-rs/core/src/rollout/list.rs
+++ b/codex-rs/core/src/rollout/list.rs
@@ -2,8 +2,8 @@ use std::cmp::Reverse;
 use std::io::{self};
 use std::num::NonZero;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicBool;
 
 use time::OffsetDateTime;
diff --git a/codex-rs/core/src/rollout/recorder.rs b/codex-rs/core/src/rollout/recorder.rs
index a39f85c8..4fba24c1 100644
--- a/codex-rs/core/src/rollout/recorder.rs
+++ b/codex-rs/core/src/rollout/recorder.rs
@@ -4,7 +4,7 @@ use std::fs::File;
 use std::fs::{self};
 use std::io::Error as IoError;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_protocol::ConversationId;
 use serde_json::Value;
@@ -18,6 +18,52 @@ use tokio::sync::oneshot;
 use tracing::info;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use super::SESSIONS_SUBDIR;
 use super::list::ConversationsPage;
 use super::list::Cursor;
diff --git a/codex-rs/core/src/safety.rs b/codex-rs/core/src/safety.rs
index 1e81981f..1da0748c 100644
--- a/codex-rs/core/src/safety.rs
+++ b/codex-rs/core/src/safety.rs
@@ -1,6 +1,6 @@
 use std::path::Component;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_apply_patch::ApplyPatchAction;
 use codex_apply_patch::ApplyPatchFileChange;
diff --git a/codex-rs/core/src/sandboxing/assessment.rs b/codex-rs/core/src/sandboxing/assessment.rs
index 31e76777..e62a8bca 100644
--- a/codex-rs/core/src/sandboxing/assessment.rs
+++ b/codex-rs/core/src/sandboxing/assessment.rs
@@ -1,7 +1,8 @@
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use crate::AuthManager;
@@ -23,6 +24,52 @@ use serde_json::json;
 use tokio::time::timeout;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 const SANDBOX_ASSESSMENT_TIMEOUT: Duration = Duration::from_secs(5);
 
 #[derive(Template)]
diff --git a/codex-rs/core/src/sandboxing/mod.rs b/codex-rs/core/src/sandboxing/mod.rs
index 5e564f51..4615f879 100644
--- a/codex-rs/core/src/sandboxing/mod.rs
+++ b/codex-rs/core/src/sandboxing/mod.rs
@@ -23,8 +23,59 @@ use crate::spawn::CODEX_SANDBOX_ENV_VAR;
 use crate::spawn::CODEX_SANDBOX_NETWORK_DISABLED_ENV_VAR;
 use crate::tools::sandboxing::SandboxablePreference;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Clone, Debug)]
 pub struct CommandSpec {
diff --git a/codex-rs/core/src/seatbelt.rs b/codex-rs/core/src/seatbelt.rs
index 8ca7e435..00473332 100644
--- a/codex-rs/core/src/seatbelt.rs
+++ b/codex-rs/core/src/seatbelt.rs
@@ -1,9 +1,60 @@
 #![cfg(target_os = "macos")]
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::ffi::CStr;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tokio::process::Child;
 
 use crate::protocol::SandboxPolicy;
@@ -162,7 +213,7 @@ mod tests {
     use pretty_assertions::assert_eq;
     use std::fs;
     use std::path::Path;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use tempfile::TempDir;
 
     #[test]
diff --git a/codex-rs/core/src/shell.rs b/codex-rs/core/src/shell.rs
index ed52491d..522594d9 100644
--- a/codex-rs/core/src/shell.rs
+++ b/codex-rs/core/src/shell.rs
@@ -1,6 +1,6 @@
 use serde::Deserialize;
 use serde::Serialize;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Debug, PartialEq, Eq, Clone, Serialize, Deserialize)]
 pub enum ShellType {
@@ -266,7 +266,7 @@ mod detect_shell_type_tests {
 #[cfg(unix)]
 mod tests {
     use super::*;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use std::process::Command;
 
     #[test]
diff --git a/codex-rs/core/src/spawn.rs b/codex-rs/core/src/spawn.rs
index d738f122..f2505db9 100644
--- a/codex-rs/core/src/spawn.rs
+++ b/codex-rs/core/src/spawn.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 use std::process::Stdio;
 use tokio::process::Child;
 use tokio::process::Command;
diff --git a/codex-rs/core/src/state/service.rs b/codex-rs/core/src/state/service.rs
index 287fb73d..0298d782 100644
--- a/codex-rs/core/src/state/service.rs
+++ b/codex-rs/core/src/state/service.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use crate::AuthManager;
 use crate::RolloutRecorder;
diff --git a/codex-rs/core/src/state/turn.rs b/codex-rs/core/src/state/turn.rs
index e2fff055..86638aa1 100644
--- a/codex-rs/core/src/state/turn.rs
+++ b/codex-rs/core/src/state/turn.rs
@@ -2,7 +2,58 @@
 
 use indexmap::IndexMap;
 use std::collections::HashMap;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::sync::{Arc, OnceLock};
 use tokio::sync::Mutex;
 use tokio::sync::Notify;
 use tokio_util::sync::CancellationToken;
diff --git a/codex-rs/core/src/tasks/compact.rs b/codex-rs/core/src/tasks/compact.rs
index 4f06d689..a8296398 100644
--- a/codex-rs/core/src/tasks/compact.rs
+++ b/codex-rs/core/src/tasks/compact.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use async_trait::async_trait;
 use tokio_util::sync::CancellationToken;
diff --git a/codex-rs/core/src/tasks/ghost_snapshot.rs b/codex-rs/core/src/tasks/ghost_snapshot.rs
index 93830a30..9dea0ea5 100644
--- a/codex-rs/core/src/tasks/ghost_snapshot.rs
+++ b/codex-rs/core/src/tasks/ghost_snapshot.rs
@@ -10,11 +10,57 @@ use codex_protocol::models::ResponseItem;
 use codex_protocol::user_input::UserInput;
 use codex_utils_readiness::Readiness;
 use codex_utils_readiness::Token;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use tokio_util::sync::CancellationToken;
 use tracing::info;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 pub(crate) struct GhostSnapshotTask {
     token: Token,
 }
diff --git a/codex-rs/core/src/tasks/mod.rs b/codex-rs/core/src/tasks/mod.rs
index 9bda02c3..dabd49c5 100644
--- a/codex-rs/core/src/tasks/mod.rs
+++ b/codex-rs/core/src/tasks/mod.rs
@@ -5,7 +5,7 @@ mod review;
 mod undo;
 mod user_shell;
 
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use async_trait::async_trait;
@@ -16,6 +16,52 @@ use tokio_util::task::AbortOnDropHandle;
 use tracing::trace;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::AuthManager;
 use crate::codex::Session;
 use crate::codex::TurnContext;
diff --git a/codex-rs/core/src/tasks/regular.rs b/codex-rs/core/src/tasks/regular.rs
index 416dba3f..55fee2ba 100644
--- a/codex-rs/core/src/tasks/regular.rs
+++ b/codex-rs/core/src/tasks/regular.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use async_trait::async_trait;
 use tokio_util::sync::CancellationToken;
diff --git a/codex-rs/core/src/tasks/review.rs b/codex-rs/core/src/tasks/review.rs
index e0bb7d4e..556339a2 100644
--- a/codex-rs/core/src/tasks/review.rs
+++ b/codex-rs/core/src/tasks/review.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use async_trait::async_trait;
 use codex_protocol::items::TurnItem;
diff --git a/codex-rs/core/src/tasks/undo.rs b/codex-rs/core/src/tasks/undo.rs
index 9862a7ec..36c0bffd 100644
--- a/codex-rs/core/src/tasks/undo.rs
+++ b/codex-rs/core/src/tasks/undo.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use crate::codex::TurnContext;
 use crate::protocol::EventMsg;
@@ -16,6 +16,52 @@ use tracing::error;
 use tracing::info;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 pub(crate) struct UndoTask;
 
 impl UndoTask {
diff --git a/codex-rs/core/src/tasks/user_shell.rs b/codex-rs/core/src/tasks/user_shell.rs
index 465517ad..f8e26d2b 100644
--- a/codex-rs/core/src/tasks/user_shell.rs
+++ b/codex-rs/core/src/tasks/user_shell.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use async_trait::async_trait;
diff --git a/codex-rs/core/src/tools/context.rs b/codex-rs/core/src/tools/context.rs
index 18b0d11e..af47e99a 100644
--- a/codex-rs/core/src/tools/context.rs
+++ b/codex-rs/core/src/tools/context.rs
@@ -11,7 +11,7 @@ use codex_protocol::models::ShellToolCallParams;
 use codex_utils_string::take_bytes_at_char_boundary;
 use mcp_types::CallToolResult;
 use std::borrow::Cow;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use tokio::sync::Mutex;
 
 pub type SharedTurnDiffTracker = Arc<Mutex<TurnDiffTracker>>;
diff --git a/codex-rs/core/src/tools/events.rs b/codex-rs/core/src/tools/events.rs
index 26dc397d..fbfffc5b 100644
--- a/codex-rs/core/src/tools/events.rs
+++ b/codex-rs/core/src/tools/events.rs
@@ -17,8 +17,59 @@ use crate::tools::context::SharedTurnDiffTracker;
 use crate::tools::sandboxing::ToolError;
 use codex_protocol::parse_command::ParsedCommand;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::time::Duration;
 
 use super::format_exec_output_str;
diff --git a/codex-rs/core/src/tools/handlers/list_dir.rs b/codex-rs/core/src/tools/handlers/list_dir.rs
index 1c08243f..615a4de3 100644
--- a/codex-rs/core/src/tools/handlers/list_dir.rs
+++ b/codex-rs/core/src/tools/handlers/list_dir.rs
@@ -2,7 +2,7 @@ use std::collections::VecDeque;
 use std::ffi::OsStr;
 use std::fs::FileType;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use async_trait::async_trait;
 use codex_utils_string::take_bytes_at_char_boundary;
diff --git a/codex-rs/core/src/tools/handlers/mcp_resource.rs b/codex-rs/core/src/tools/handlers/mcp_resource.rs
index 4dac72fb..01ca2d66 100644
--- a/codex-rs/core/src/tools/handlers/mcp_resource.rs
+++ b/codex-rs/core/src/tools/handlers/mcp_resource.rs
@@ -1,6 +1,58 @@
 use std::collections::HashMap;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use async_trait::async_trait;
diff --git a/codex-rs/core/src/tools/handlers/read_file.rs b/codex-rs/core/src/tools/handlers/read_file.rs
index 58b6ea68..0b814c74 100644
--- a/codex-rs/core/src/tools/handlers/read_file.rs
+++ b/codex-rs/core/src/tools/handlers/read_file.rs
@@ -1,5 +1,5 @@
 use std::collections::VecDeque;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use async_trait::async_trait;
 use codex_utils_string::take_bytes_at_char_boundary;
@@ -114,12 +114,13 @@ impl ToolHandler for ReadFileHandler {
         })?;
 
         let ReadFileArgs {
-            file_path,
-            offset,
-            limit,
-            mode,
-            indentation,
+            mut file_path,
+            mut offset,
+            mut limit,
+            mut mode,
+            mut indentation,
         } = args;
+        
 
         if offset == 0 {
             return Err(FunctionCallError::RespondToModel(
diff --git a/codex-rs/core/src/tools/handlers/shell.rs b/codex-rs/core/src/tools/handlers/shell.rs
index 173a3ccf..c8255c49 100644
--- a/codex-rs/core/src/tools/handlers/shell.rs
+++ b/codex-rs/core/src/tools/handlers/shell.rs
@@ -1,7 +1,7 @@
 use async_trait::async_trait;
 use codex_protocol::models::ShellCommandToolCallParams;
 use codex_protocol::models::ShellToolCallParams;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use crate::apply_patch;
 use crate::apply_patch::InternalApplyPatchInvocation;
@@ -327,7 +327,7 @@ impl ShellHandler {
 
 #[cfg(test)]
 mod tests {
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
 
     use crate::is_safe_command::is_known_safe_command;
     use crate::shell::BashShell;
diff --git a/codex-rs/core/src/tools/handlers/test_sync.rs b/codex-rs/core/src/tools/handlers/test_sync.rs
index d217c1e8..1004b99b 100644
--- a/codex-rs/core/src/tools/handlers/test_sync.rs
+++ b/codex-rs/core/src/tools/handlers/test_sync.rs
@@ -1,6 +1,57 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::collections::hash_map::Entry;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::OnceLock;
 use std::time::Duration;
 
diff --git a/codex-rs/core/src/tools/handlers/unified_exec.rs b/codex-rs/core/src/tools/handlers/unified_exec.rs
index 6790b735..be89983c 100644
--- a/codex-rs/core/src/tools/handlers/unified_exec.rs
+++ b/codex-rs/core/src/tools/handlers/unified_exec.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::function_tool::FunctionCallError;
 use crate::is_safe_command::is_known_safe_command;
@@ -56,8 +56,8 @@ struct WriteStdinArgs {
 }
 
 fn default_exec_yield_time_ms() -> u64 {
-    10000
-}
+      1000
+  }
 
 fn default_write_stdin_yield_time_ms() -> u64 {
     250
diff --git a/codex-rs/core/src/tools/parallel.rs b/codex-rs/core/src/tools/parallel.rs
index 33dc42b9..a884b573 100644
--- a/codex-rs/core/src/tools/parallel.rs
+++ b/codex-rs/core/src/tools/parallel.rs
@@ -1,4 +1,5 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use tokio::sync::RwLock;
diff --git a/codex-rs/core/src/tools/registry.rs b/codex-rs/core/src/tools/registry.rs
index f35ff063..6ad9a2bd 100644
--- a/codex-rs/core/src/tools/registry.rs
+++ b/codex-rs/core/src/tools/registry.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use crate::client_common::tools::ToolSpec;
@@ -12,6 +63,52 @@ use codex_protocol::models::ResponseInputItem;
 use codex_utils_readiness::Readiness;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 pub enum ToolKind {
     Function,
diff --git a/codex-rs/core/src/tools/router.rs b/codex-rs/core/src/tools/router.rs
index 7152d3c1..797910fc 100644
--- a/codex-rs/core/src/tools/router.rs
+++ b/codex-rs/core/src/tools/router.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::sync::{Arc, OnceLock};
 
 use crate::client_common::tools::ToolSpec;
 use crate::codex::Session;
diff --git a/codex-rs/core/src/tools/runtimes/apply_patch.rs b/codex-rs/core/src/tools/runtimes/apply_patch.rs
index 0cdddd50..2b1cea26 100644
--- a/codex-rs/core/src/tools/runtimes/apply_patch.rs
+++ b/codex-rs/core/src/tools/runtimes/apply_patch.rs
@@ -23,7 +23,58 @@ use codex_protocol::protocol::AskForApproval;
 use codex_protocol::protocol::ReviewDecision;
 use futures::future::BoxFuture;
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 #[derive(Clone, Debug)]
 pub struct ApplyPatchRequest {
diff --git a/codex-rs/core/src/tools/runtimes/mod.rs b/codex-rs/core/src/tools/runtimes/mod.rs
index 212163d7..8640003f 100644
--- a/codex-rs/core/src/tools/runtimes/mod.rs
+++ b/codex-rs/core/src/tools/runtimes/mod.rs
@@ -7,6 +7,57 @@ small and focused and reuses the orchestrator for approvals + sandbox + retry.
 use crate::sandboxing::CommandSpec;
 use crate::tools::sandboxing::ToolError;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
 
 pub mod apply_patch;
diff --git a/codex-rs/core/src/tools/runtimes/shell.rs b/codex-rs/core/src/tools/runtimes/shell.rs
index bf7ae7fa..9f5fa47d 100644
--- a/codex-rs/core/src/tools/runtimes/shell.rs
+++ b/codex-rs/core/src/tools/runtimes/shell.rs
@@ -23,7 +23,7 @@ use crate::tools::sandboxing::with_cached_approval;
 use codex_protocol::protocol::AskForApproval;
 use codex_protocol::protocol::ReviewDecision;
 use futures::future::BoxFuture;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Clone, Debug)]
 pub struct ShellRequest {
diff --git a/codex-rs/core/src/tools/runtimes/unified_exec.rs b/codex-rs/core/src/tools/runtimes/unified_exec.rs
index cddac192..105cbe7f 100644
--- a/codex-rs/core/src/tools/runtimes/unified_exec.rs
+++ b/codex-rs/core/src/tools/runtimes/unified_exec.rs
@@ -27,7 +27,58 @@ use codex_protocol::protocol::ReviewDecision;
 use codex_protocol::protocol::SandboxPolicy;
 use futures::future::BoxFuture;
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 #[derive(Clone, Debug)]
 pub struct UnifiedExecRequest {
diff --git a/codex-rs/core/src/tools/sandboxing.rs b/codex-rs/core/src/tools/sandboxing.rs
index da1c22b5..fc1d37f7 100644
--- a/codex-rs/core/src/tools/sandboxing.rs
+++ b/codex-rs/core/src/tools/sandboxing.rs
@@ -16,10 +16,61 @@ use crate::state::SessionServices;
 use codex_protocol::protocol::AskForApproval;
 use codex_protocol::protocol::ReviewDecision;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::fmt::Debug;
 use std::hash::Hash;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use futures::Future;
 use futures::future::BoxFuture;
diff --git a/codex-rs/core/src/tools/spec.rs b/codex-rs/core/src/tools/spec.rs
index 28e88c38..c14e2cd2 100644
--- a/codex-rs/core/src/tools/spec.rs
+++ b/codex-rs/core/src/tools/spec.rs
@@ -14,6 +14,57 @@ use serde_json::Value as JsonValue;
 use serde_json::json;
 use std::collections::BTreeMap;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub enum ConfigShellToolType {
@@ -987,7 +1038,7 @@ pub(crate) fn build_specs(
     use crate::tools::handlers::TestSyncHandler;
     use crate::tools::handlers::UnifiedExecHandler;
     use crate::tools::handlers::ViewImageHandler;
-    use std::sync::Arc;
+    use std::sync::{Arc, OnceLock};
 
     let mut builder = ToolRegistryBuilder::new();
 
diff --git a/codex-rs/core/src/turn_diff_tracker.rs b/codex-rs/core/src/turn_diff_tracker.rs
index 06c40deb..a2e7ffa2 100644
--- a/codex-rs/core/src/turn_diff_tracker.rs
+++ b/codex-rs/core/src/turn_diff_tracker.rs
@@ -1,7 +1,58 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::fs;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process::Command;
 
 use anyhow::Context;
diff --git a/codex-rs/core/src/unified_exec/mod.rs b/codex-rs/core/src/unified_exec/mod.rs
index f77b7444..ba6e7cf0 100644
--- a/codex-rs/core/src/unified_exec/mod.rs
+++ b/codex-rs/core/src/unified_exec/mod.rs
@@ -22,8 +22,59 @@
 //! - `session_manager.rs`: orchestration (approvals, sandboxing, reuse) and request handling.
 
 use std::collections::HashMap;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicI32;
 use std::time::Duration;
 
@@ -42,7 +93,7 @@ pub(crate) use errors::UnifiedExecError;
 pub(crate) use session::UnifiedExecSession;
 
 pub(crate) const MIN_YIELD_TIME_MS: u64 = 250;
-pub(crate) const MAX_YIELD_TIME_MS: u64 = 30_000;
+pub(crate) const MAX_YIELD_TIME_MS: u64 = 5_000;
 pub(crate) const DEFAULT_MAX_OUTPUT_TOKENS: usize = 10_000;
 pub(crate) const UNIFIED_EXEC_OUTPUT_MAX_BYTES: usize = 1024 * 1024; // 1 MiB
 
@@ -136,7 +187,7 @@ mod tests {
     use crate::unified_exec::ExecCommandRequest;
     use crate::unified_exec::WriteStdinRequest;
     use core_test_support::skip_if_sandbox;
-    use std::sync::Arc;
+    use std::sync::{Arc, OnceLock};
     use tokio::time::Duration;
 
     use super::session::OutputBufferState;
diff --git a/codex-rs/core/src/unified_exec/session.rs b/codex-rs/core/src/unified_exec/session.rs
index bdb935f1..adda3b16 100644
--- a/codex-rs/core/src/unified_exec/session.rs
+++ b/codex-rs/core/src/unified_exec/session.rs
@@ -1,7 +1,7 @@
 #![allow(clippy::module_inception)]
 
 use std::collections::VecDeque;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use tokio::sync::Mutex;
 use tokio::sync::Notify;
diff --git a/codex-rs/core/src/unified_exec/session_manager.rs b/codex-rs/core/src/unified_exec/session_manager.rs
index fee46df8..58c507e8 100644
--- a/codex-rs/core/src/unified_exec/session_manager.rs
+++ b/codex-rs/core/src/unified_exec/session_manager.rs
@@ -1,5 +1,5 @@
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 
 use tokio::sync::Notify;
 use tokio::sync::mpsc;
@@ -96,6 +96,8 @@ impl UnifiedExecSessionManager {
             session_command: Some(request.command.clone()),
         };
 
+        log_unified_exec_chunk("exec_command", &response);
+        
         if response.session_id.is_some() {
             Self::emit_waiting_status(&context.session, &context.turn, &request.command).await;
         }
@@ -218,6 +220,8 @@ impl UnifiedExecSessionManager {
             )
             .await;
 
+        log_unified_exec_chunk("exec_command", &response);
+        
         if response.session_id.is_some() {
             Self::emit_waiting_status(&session_ref, &turn_ref, &session_command).await;
         }
@@ -499,9 +503,7 @@ impl UnifiedExecSessionManager {
                 collected.extend_from_slice(&chunk);
             }
 
-            if Instant::now() >= deadline {
-                break;
-            }
+            
         }
 
         collected
diff --git a/codex-rs/core/src/user_notification.rs b/codex-rs/core/src/user_notification.rs
index 7bbd1d95..73a90368 100644
--- a/codex-rs/core/src/user_notification.rs
+++ b/codex-rs/core/src/user_notification.rs
@@ -2,6 +2,52 @@ use serde::Serialize;
 use tracing::error;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 #[derive(Debug, Default)]
 pub(crate) struct UserNotifier {
     notify_command: Option<Vec<String>>,
diff --git a/codex-rs/core/tests/chat_completions_payload.rs b/codex-rs/core/tests/chat_completions_payload.rs
index accac55e..4e68bb65 100644
--- a/codex-rs/core/tests/chat_completions_payload.rs
+++ b/codex-rs/core/tests/chat_completions_payload.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use codex_app_server_protocol::AuthMode;
 use codex_core::ContentItem;
diff --git a/codex-rs/core/tests/chat_completions_sse.rs b/codex-rs/core/tests/chat_completions_sse.rs
index 7b871636..dbc4d069 100644
--- a/codex-rs/core/tests/chat_completions_sse.rs
+++ b/codex-rs/core/tests/chat_completions_sse.rs
@@ -1,5 +1,5 @@
 use assert_matches::assert_matches;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use tracing_test::traced_test;
 
 use codex_app_server_protocol::AuthMode;
diff --git a/codex-rs/core/tests/common/lib.rs b/codex-rs/core/tests/common/lib.rs
index 3f75ed18..652b8758 100644
--- a/codex-rs/core/tests/common/lib.rs
+++ b/codex-rs/core/tests/common/lib.rs
@@ -178,10 +178,11 @@ pub mod fs_wait {
     use notify::RecursiveMode;
     use notify::Watcher;
     use std::path::Path;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use std::sync::mpsc;
     use std::sync::mpsc::RecvTimeoutError;
     use std::time::Duration;
+    use std::sync::OnceLock;
     use std::time::Instant;
     use tokio::task;
     use walkdir::WalkDir;
diff --git a/codex-rs/core/tests/common/responses.rs b/codex-rs/core/tests/common/responses.rs
index 2c88dd8f..3fc3d88e 100644
--- a/codex-rs/core/tests/common/responses.rs
+++ b/codex-rs/core/tests/common/responses.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::Mutex;
 
 use anyhow::Result;
diff --git a/codex-rs/core/tests/common/test_codex.rs b/codex-rs/core/tests/common/test_codex.rs
index e88c410e..db7a0f25 100644
--- a/codex-rs/core/tests/common/test_codex.rs
+++ b/codex-rs/core/tests/common/test_codex.rs
@@ -1,7 +1,7 @@
 use std::mem::swap;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 
 use anyhow::Result;
 use codex_core::CodexAuth;
diff --git a/codex-rs/core/tests/responses_headers.rs b/codex-rs/core/tests/responses_headers.rs
index 7b6f645f..70f6638b 100644
--- a/codex-rs/core/tests/responses_headers.rs
+++ b/codex-rs/core/tests/responses_headers.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use codex_app_server_protocol::AuthMode;
 use codex_core::ContentItem;
diff --git a/codex-rs/core/tests/suite/abort_tasks.rs b/codex-rs/core/tests/suite/abort_tasks.rs
index 17746198..1bf0c461 100644
--- a/codex-rs/core/tests/suite/abort_tasks.rs
+++ b/codex-rs/core/tests/suite/abort_tasks.rs
@@ -1,5 +1,5 @@
 use assert_matches::assert_matches;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use codex_core::protocol::EventMsg;
diff --git a/codex-rs/core/tests/suite/approvals.rs b/codex-rs/core/tests/suite/approvals.rs
index a106d2ea..114bc044 100644
--- a/codex-rs/core/tests/suite/approvals.rs
+++ b/codex-rs/core/tests/suite/approvals.rs
@@ -30,7 +30,7 @@ use serde_json::Value;
 use serde_json::json;
 use std::env;
 use std::fs;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use wiremock::Mock;
 use wiremock::MockServer;
 use wiremock::ResponseTemplate;
diff --git a/codex-rs/core/tests/suite/client.rs b/codex-rs/core/tests/suite/client.rs
index fefb18f3..04f1e84b 100644
--- a/codex-rs/core/tests/suite/client.rs
+++ b/codex-rs/core/tests/suite/client.rs
@@ -37,7 +37,7 @@ use core_test_support::wait_for_event;
 use futures::StreamExt;
 use serde_json::json;
 use std::io::Write;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use tempfile::TempDir;
 use uuid::Uuid;
 use wiremock::Mock;
diff --git a/codex-rs/core/tests/suite/compact_resume_fork.rs b/codex-rs/core/tests/suite/compact_resume_fork.rs
index f5ed7772..715ea68e 100644
--- a/codex-rs/core/tests/suite/compact_resume_fork.rs
+++ b/codex-rs/core/tests/suite/compact_resume_fork.rs
@@ -32,7 +32,7 @@ use core_test_support::wait_for_event;
 use pretty_assertions::assert_eq;
 use serde_json::Value;
 use serde_json::json;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use tempfile::TempDir;
 use wiremock::MockServer;
 
diff --git a/codex-rs/core/tests/suite/exec.rs b/codex-rs/core/tests/suite/exec.rs
index ea5ab848..5b0a5dd8 100644
--- a/codex-rs/core/tests/suite/exec.rs
+++ b/codex-rs/core/tests/suite/exec.rs
@@ -1,6 +1,57 @@
 #![cfg(target_os = "macos")]
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::string::ToString;
 
 use codex_core::exec::ExecParams;
diff --git a/codex-rs/core/tests/suite/prompt_caching.rs b/codex-rs/core/tests/suite/prompt_caching.rs
index c858ea20..f7308415 100644
--- a/codex-rs/core/tests/suite/prompt_caching.rs
+++ b/codex-rs/core/tests/suite/prompt_caching.rs
@@ -20,6 +20,57 @@ use core_test_support::test_codex::TestCodex;
 use core_test_support::test_codex::test_codex;
 use core_test_support::wait_for_event;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use tempfile::TempDir;
 
 fn text_user_input(text: String) -> serde_json::Value {
diff --git a/codex-rs/core/tests/suite/resume.rs b/codex-rs/core/tests/suite/resume.rs
index bda27533..bf836104 100644
--- a/codex-rs/core/tests/suite/resume.rs
+++ b/codex-rs/core/tests/suite/resume.rs
@@ -12,7 +12,7 @@ use core_test_support::responses::start_mock_server;
 use core_test_support::skip_if_no_network;
 use core_test_support::test_codex::test_codex;
 use core_test_support::wait_for_event;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 #[tokio::test(flavor = "multi_thread", worker_threads = 2)]
 async fn resume_includes_initial_messages_from_rollout_events() -> Result<()> {
diff --git a/codex-rs/core/tests/suite/review.rs b/codex-rs/core/tests/suite/review.rs
index 9c3f812c..561f87bf 100644
--- a/codex-rs/core/tests/suite/review.rs
+++ b/codex-rs/core/tests/suite/review.rs
@@ -24,8 +24,8 @@ use core_test_support::load_sse_fixture_with_id_from_str;
 use core_test_support::skip_if_no_network;
 use core_test_support::wait_for_event;
 use pretty_assertions::assert_eq;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use tempfile::TempDir;
 use tokio::io::AsyncWriteExt as _;
 use uuid::Uuid;
diff --git a/codex-rs/core/tests/suite/rmcp_client.rs b/codex-rs/core/tests/suite/rmcp_client.rs
index cc653a9c..a9c7fc09 100644
--- a/codex-rs/core/tests/suite/rmcp_client.rs
+++ b/codex-rs/core/tests/suite/rmcp_client.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::ffi::OsStr;
 use std::ffi::OsString;
 use std::fs;
diff --git a/codex-rs/core/tests/suite/rollout_list_find.rs b/codex-rs/core/tests/suite/rollout_list_find.rs
index 1d40718d..48f5e51f 100644
--- a/codex-rs/core/tests/suite/rollout_list_find.rs
+++ b/codex-rs/core/tests/suite/rollout_list_find.rs
@@ -1,7 +1,7 @@
 #![allow(clippy::unwrap_used, clippy::expect_used)]
 use std::io::Write;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::find_conversation_path_by_id_str;
 use tempfile::TempDir;
diff --git a/codex-rs/core/tests/suite/seatbelt.rs b/codex-rs/core/tests/suite/seatbelt.rs
index 53175fca..ef4442cd 100644
--- a/codex-rs/core/tests/suite/seatbelt.rs
+++ b/codex-rs/core/tests/suite/seatbelt.rs
@@ -4,8 +4,59 @@
 //! Tests that apply to both Mac and Linux sandboxing should go in sandbox.rs.
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::protocol::SandboxPolicy;
 use codex_core::seatbelt::spawn_command_under_seatbelt;
diff --git a/codex-rs/core/tests/suite/tool_parallelism.rs b/codex-rs/core/tests/suite/tool_parallelism.rs
index 807bb9d8..7380ebbf 100644
--- a/codex-rs/core/tests/suite/tool_parallelism.rs
+++ b/codex-rs/core/tests/suite/tool_parallelism.rs
@@ -2,6 +2,7 @@
 #![allow(clippy::unwrap_used)]
 
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use codex_core::model_family::find_family_for_model;
diff --git a/codex-rs/core/tests/suite/tools.rs b/codex-rs/core/tests/suite/tools.rs
index 549d6e7d..36f37a89 100644
--- a/codex-rs/core/tests/suite/tools.rs
+++ b/codex-rs/core/tests/suite/tools.rs
@@ -3,6 +3,7 @@
 
 use std::fs;
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use anyhow::Context;
diff --git a/codex-rs/core/tests/suite/truncation.rs b/codex-rs/core/tests/suite/truncation.rs
index 200d27e8..fcf66abe 100644
--- a/codex-rs/core/tests/suite/truncation.rs
+++ b/codex-rs/core/tests/suite/truncation.rs
@@ -31,6 +31,57 @@ use regex_lite::Regex;
 use serde_json::Value;
 use serde_json::json;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::time::Duration;
 
 // Verifies byte-truncation formatting for function error output (RespondToModel errors)
diff --git a/codex-rs/core/tests/suite/undo.rs b/codex-rs/core/tests/suite/undo.rs
index 6dcb8e81..7b40ee2f 100644
--- a/codex-rs/core/tests/suite/undo.rs
+++ b/codex-rs/core/tests/suite/undo.rs
@@ -3,7 +3,7 @@
 use std::fs;
 use std::path::Path;
 use std::process::Command;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use anyhow::Context;
 use anyhow::Result;
diff --git a/codex-rs/core/tests/suite/unified_exec.rs b/codex-rs/core/tests/suite/unified_exec.rs
index 970be527..fdb4d152 100644
--- a/codex-rs/core/tests/suite/unified_exec.rs
+++ b/codex-rs/core/tests/suite/unified_exec.rs
@@ -1,5 +1,56 @@
 #![cfg(not(target_os = "windows"))]
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::sync::OnceLock;
 
 use anyhow::Context;
diff --git a/codex-rs/core/tests/suite/user_shell_cmd.rs b/codex-rs/core/tests/suite/user_shell_cmd.rs
index 0d42c45c..ab66c389 100644
--- a/codex-rs/core/tests/suite/user_shell_cmd.rs
+++ b/codex-rs/core/tests/suite/user_shell_cmd.rs
@@ -24,7 +24,7 @@ use core_test_support::test_codex::test_codex;
 use core_test_support::wait_for_event;
 use core_test_support::wait_for_event_match;
 use regex_lite::escape;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tempfile::TempDir;
 
 #[tokio::test]
diff --git a/codex-rs/exec/src/cli.rs b/codex-rs/exec/src/cli.rs
index ef20bf6f..9082de6e 100644
--- a/codex-rs/exec/src/cli.rs
+++ b/codex-rs/exec/src/cli.rs
@@ -1,7 +1,7 @@
 use clap::Parser;
 use clap::ValueEnum;
 use codex_common::CliConfigOverrides;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Parser, Debug)]
 #[command(version)]
diff --git a/codex-rs/exec/src/event_processor_with_human_output.rs b/codex-rs/exec/src/event_processor_with_human_output.rs
index 8c7bb688..565c8a39 100644
--- a/codex-rs/exec/src/event_processor_with_human_output.rs
+++ b/codex-rs/exec/src/event_processor_with_human_output.rs
@@ -28,7 +28,59 @@ use owo_colors::OwoColorize;
 use owo_colors::Style;
 use shlex::try_join;
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use crate::event_processor::CodexStatus;
@@ -281,11 +333,17 @@ impl EventProcessor for EventProcessorWithHumanOutput {
             }) => {
                 let duration = format!(" in {}", format_duration(duration));
 
-                let truncated_output = aggregated_output
-                    .lines()
-                    .take(MAX_OUTPUT_LINES_FOR_EXEC_TOOL_CALL)
-                    .collect::<Vec<_>>()
-                    .join("\n");
+                let output_cap = exec_output_line_cap();
+                let truncated_output = if let Some(cap) = output_cap {
+                    aggregated_output
+                        .lines()
+                        .take(cap)
+                        .collect::<Vec<_>>()
+                        .join("\n")
+                } else {
+                    aggregated_output
+                };
+                
                 match exit_code {
                     0 => {
                         let title = format!(" succeeded{duration}:");
@@ -334,9 +392,16 @@ impl EventProcessor for EventProcessorWithHumanOutput {
                     let pretty =
                         serde_json::to_string_pretty(&val).unwrap_or_else(|_| val.to_string());
 
-                    for line in pretty.lines().take(MAX_OUTPUT_LINES_FOR_EXEC_TOOL_CALL) {
-                        eprintln!("{}", line.style(self.dimmed));
+                    if let Some(cap) = exec_output_line_cap() {
+                        for line in pretty.lines().take(cap) {
+                            eprintln!("{}", line.style(self.dimmed));
+                        }
+                    } else {
+                        for line in pretty.lines() {
+                            eprintln!("{}", line.style(self.dimmed));
+                        }
                     }
+                    
                 }
             }
             EventMsg::WebSearchEnd(WebSearchEndEvent { call_id: _, query }) => {
diff --git a/codex-rs/exec/src/event_processor_with_jsonl_output.rs b/codex-rs/exec/src/event_processor_with_jsonl_output.rs
index 23dff015..455dee7c 100644
--- a/codex-rs/exec/src/event_processor_with_jsonl_output.rs
+++ b/codex-rs/exec/src/event_processor_with_jsonl_output.rs
@@ -1,6 +1,61 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicU64;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use std::time::{SystemTime, UNIX_EPOCH};
 
 use crate::event_processor::CodexStatus;
 use crate::event_processor::EventProcessor;
@@ -55,6 +110,52 @@ use serde_json::Value as JsonValue;
 use tracing::error;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 pub struct EventProcessorWithJsonOutput {
     last_message_path: Option<PathBuf>,
     next_event_id: AtomicU64,
diff --git a/codex-rs/exec/src/lib.rs b/codex-rs/exec/src/lib.rs
index a003b4ff..b6e96cd1 100644
--- a/codex-rs/exec/src/lib.rs
+++ b/codex-rs/exec/src/lib.rs
@@ -38,7 +38,7 @@ use opentelemetry_appender_tracing::layer::OpenTelemetryTracingBridge;
 use serde_json::Value;
 use std::io::IsTerminal;
 use std::io::Read;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use supports_color::Stream;
 use tracing::debug;
 use tracing::error;
diff --git a/codex-rs/exec/tests/event_processor_with_json_output.rs b/codex-rs/exec/tests/event_processor_with_json_output.rs
index 7a6245ae..bcd83145 100644
--- a/codex-rs/exec/tests/event_processor_with_json_output.rs
+++ b/codex-rs/exec/tests/event_processor_with_json_output.rs
@@ -50,7 +50,7 @@ use mcp_types::ContentBlock;
 use mcp_types::TextContent;
 use pretty_assertions::assert_eq;
 use serde_json::json;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::time::Duration;
 
 fn event(id: &str, msg: EventMsg) -> Event {
diff --git a/codex-rs/exec/tests/suite/sandbox.rs b/codex-rs/exec/tests/suite/sandbox.rs
index 73a7f0d5..015fa8c2 100644
--- a/codex-rs/exec/tests/suite/sandbox.rs
+++ b/codex-rs/exec/tests/suite/sandbox.rs
@@ -2,10 +2,61 @@
 use codex_core::protocol::SandboxPolicy;
 use codex_core::spawn::StdioPolicy;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::future::Future;
 use std::io;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process::ExitStatus;
 use tokio::fs::create_dir_all;
 use tokio::process::Child;
diff --git a/codex-rs/execpolicy/src/error.rs b/codex-rs/execpolicy/src/error.rs
index e6443d69..92792a0b 100644
--- a/codex-rs/execpolicy/src/error.rs
+++ b/codex-rs/execpolicy/src/error.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use serde::Serialize;
 
diff --git a/codex-rs/execpolicy/src/execv_checker.rs b/codex-rs/execpolicy/src/execv_checker.rs
index e84b92ca..71c46e16 100644
--- a/codex-rs/execpolicy/src/execv_checker.rs
+++ b/codex-rs/execpolicy/src/execv_checker.rs
@@ -1,7 +1,7 @@
 use std::borrow::Cow;
 use std::ffi::OsString;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::ArgType;
 use crate::Error::CannotCanonicalizePath;
diff --git a/codex-rs/execpolicy/src/main.rs b/codex-rs/execpolicy/src/main.rs
index 68a72c04..9d358e0b 100644
--- a/codex-rs/execpolicy/src/main.rs
+++ b/codex-rs/execpolicy/src/main.rs
@@ -11,7 +11,7 @@ use serde::Deserialize;
 use serde::Serialize;
 use serde::de;
 use starlark::Error as StarlarkError;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::str::FromStr;
 
 const MATCHED_BUT_WRITES_FILES_EXIT_CODE: i32 = 12;
diff --git a/codex-rs/execpolicy/src/policy_parser.rs b/codex-rs/execpolicy/src/policy_parser.rs
index b065c109..0a4bbd9b 100644
--- a/codex-rs/execpolicy/src/policy_parser.rs
+++ b/codex-rs/execpolicy/src/policy_parser.rs
@@ -20,6 +20,57 @@ use starlark::values::list::UnpackList;
 use starlark::values::none::NoneType;
 use std::cell::RefCell;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 pub struct PolicyParser {
     policy_source: String,
diff --git a/codex-rs/execpolicy/src/program.rs b/codex-rs/execpolicy/src/program.rs
index d0cec371..8a2d0a30 100644
--- a/codex-rs/execpolicy/src/program.rs
+++ b/codex-rs/execpolicy/src/program.rs
@@ -1,5 +1,56 @@
 use serde::Serialize;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::collections::HashSet;
 
 use crate::ArgType;
diff --git a/codex-rs/execpolicy2/src/main.rs b/codex-rs/execpolicy2/src/main.rs
index f654c5f8..c49a6ed0 100644
--- a/codex-rs/execpolicy2/src/main.rs
+++ b/codex-rs/execpolicy2/src/main.rs
@@ -1,5 +1,5 @@
 use std::fs;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use anyhow::Context;
 use anyhow::Result;
diff --git a/codex-rs/execpolicy2/src/parser.rs b/codex-rs/execpolicy2/src/parser.rs
index d5054905..d5d33009 100644
--- a/codex-rs/execpolicy2/src/parser.rs
+++ b/codex-rs/execpolicy2/src/parser.rs
@@ -13,7 +13,7 @@ use starlark::values::list::UnpackList;
 use starlark::values::none::NoneType;
 use std::cell::RefCell;
 use std::cell::RefMut;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use crate::decision::Decision;
 use crate::error::Error;
diff --git a/codex-rs/execpolicy2/src/rule.rs b/codex-rs/execpolicy2/src/rule.rs
index 20e23fe6..293f1dbd 100644
--- a/codex-rs/execpolicy2/src/rule.rs
+++ b/codex-rs/execpolicy2/src/rule.rs
@@ -6,7 +6,7 @@ use serde::Serialize;
 use shlex::try_join;
 use std::any::Any;
 use std::fmt::Debug;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 /// Matches a single command token, either a fixed string or one of several allowed alternatives.
 #[derive(Clone, Debug, Eq, PartialEq)]
diff --git a/codex-rs/execpolicy2/tests/basic.rs b/codex-rs/execpolicy2/tests/basic.rs
index 75921ecd..36a27890 100644
--- a/codex-rs/execpolicy2/tests/basic.rs
+++ b/codex-rs/execpolicy2/tests/basic.rs
@@ -1,5 +1,5 @@
 use std::any::Any;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use codex_execpolicy2::Decision;
 use codex_execpolicy2::Evaluation;
diff --git a/codex-rs/feedback/src/lib.rs b/codex-rs/feedback/src/lib.rs
index e1ccc3aa..86164686 100644
--- a/codex-rs/feedback/src/lib.rs
+++ b/codex-rs/feedback/src/lib.rs
@@ -2,8 +2,8 @@ use std::collections::VecDeque;
 use std::fs;
 use std::io::Write;
 use std::io::{self};
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::Mutex;
 use std::time::Duration;
 
@@ -178,7 +178,7 @@ impl CodexLogSnapshot {
         use std::collections::BTreeMap;
         use std::fs;
         use std::str::FromStr;
-        use std::sync::Arc;
+        use std::sync::{Arc, OnceLock};
 
         use sentry::Client;
         use sentry::ClientOptions;
diff --git a/codex-rs/file-search/src/cli.rs b/codex-rs/file-search/src/cli.rs
index e3394f92..489cfd8e 100644
--- a/codex-rs/file-search/src/cli.rs
+++ b/codex-rs/file-search/src/cli.rs
@@ -1,5 +1,5 @@
 use std::num::NonZero;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use clap::ArgAction;
 use clap::Parser;
diff --git a/codex-rs/file-search/src/lib.rs b/codex-rs/file-search/src/lib.rs
index 0afc9ea6..59fffda1 100644
--- a/codex-rs/file-search/src/lib.rs
+++ b/codex-rs/file-search/src/lib.rs
@@ -12,7 +12,7 @@ use std::cmp::Reverse;
 use std::collections::BinaryHeap;
 use std::num::NonZero;
 use std::path::Path;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicBool;
 use std::sync::atomic::AtomicUsize;
 use std::sync::atomic::Ordering;
diff --git a/codex-rs/keyring-store/src/lib.rs b/codex-rs/keyring-store/src/lib.rs
index 10dad3a9..29200278 100644
--- a/codex-rs/keyring-store/src/lib.rs
+++ b/codex-rs/keyring-store/src/lib.rs
@@ -113,7 +113,58 @@ pub mod tests {
     use keyring::credential::CredentialApi as _;
     use keyring::mock::MockCredential;
     use std::collections::HashMap;
-    use std::sync::Arc;
+    use std::env;
+    use std::fs::OpenOptions;
+    use std::io::Write;
+    use serde_json::json;
+    use tracing::warn;
+    
+    static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+    
+    fn event_trace_path() -> Option<&'static PathBuf> {
+        EVENT_TRACE_PATH
+            .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                Some(path) if !path.is_empty() => {
+                    let file = PathBuf::from(path);
+                    if let Some(parent) = file.parent() {
+                        if let Err(err) = std::fs::create_dir_all(parent) {
+                            warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                            return None;
+                        }
+                    }
+                    Some(file)
+                }
+                _ => None,
+            })
+            .as_ref()
+    }
+    
+    fn log_event_for_hypebrut(event: &Event) {
+        let Some(path) = event_trace_path() else {
+            return;
+        };
+    
+        let timestamp = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_default()
+            .as_secs_f64();
+    
+        let payload = serde_json::json!({
+            \"ts\": timestamp,
+            \"event\": event,
+        });
+    
+        if let Err(err) = append_event_line(path, payload.to_string()) {
+            warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+        }
+    }
+    
+    fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+        let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+        file.write_all(line.as_bytes())?;
+        file.write_all(b\"\\n\")
+    }
+    use std::sync::{Arc, OnceLock};
     use std::sync::Mutex;
     use std::sync::PoisonError;
 
diff --git a/codex-rs/linux-sandbox/src/landlock.rs b/codex-rs/linux-sandbox/src/landlock.rs
index 5bc96130..93bc486a 100644
--- a/codex-rs/linux-sandbox/src/landlock.rs
+++ b/codex-rs/linux-sandbox/src/landlock.rs
@@ -1,6 +1,6 @@
 use std::collections::BTreeMap;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::error::CodexErr;
 use codex_core::error::Result;
diff --git a/codex-rs/linux-sandbox/src/linux_run_main.rs b/codex-rs/linux-sandbox/src/linux_run_main.rs
index c4b0767f..e25b1eb1 100644
--- a/codex-rs/linux-sandbox/src/linux_run_main.rs
+++ b/codex-rs/linux-sandbox/src/linux_run_main.rs
@@ -1,6 +1,6 @@
 use clap::Parser;
 use std::ffi::CString;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::landlock::apply_sandbox_policy_to_current_thread;
 
diff --git a/codex-rs/linux-sandbox/tests/suite/landlock.rs b/codex-rs/linux-sandbox/tests/suite/landlock.rs
index 508dba08..5fd509b5 100644
--- a/codex-rs/linux-sandbox/tests/suite/landlock.rs
+++ b/codex-rs/linux-sandbox/tests/suite/landlock.rs
@@ -8,7 +8,58 @@ use codex_core::exec::process_exec_tool_call;
 use codex_core::exec_env::create_env;
 use codex_core::protocol::SandboxPolicy;
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 use tempfile::NamedTempFile;
 
 // At least on GitHub CI, the arm64 tests appear to need longer timeouts.
diff --git a/codex-rs/login/src/device_code_auth.rs b/codex-rs/login/src/device_code_auth.rs
index acaf30ba..958248cc 100644
--- a/codex-rs/login/src/device_code_auth.rs
+++ b/codex-rs/login/src/device_code_auth.rs
@@ -4,6 +4,7 @@ use serde::Serialize;
 use serde::de::Deserializer;
 use serde::de::{self};
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use crate::pkce::PkceCodes;
diff --git a/codex-rs/login/src/server.rs b/codex-rs/login/src/server.rs
index 999c1907..bccfb20f 100644
--- a/codex-rs/login/src/server.rs
+++ b/codex-rs/login/src/server.rs
@@ -5,8 +5,8 @@ use std::io::{self};
 use std::net::SocketAddr;
 use std::net::TcpStream;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::thread;
 use std::time::Duration;
 
diff --git a/codex-rs/login/tests/suite/device_code_login.rs b/codex-rs/login/tests/suite/device_code_login.rs
index 266930e4..33c45146 100644
--- a/codex-rs/login/tests/suite/device_code_login.rs
+++ b/codex-rs/login/tests/suite/device_code_login.rs
@@ -8,7 +8,7 @@ use codex_core::auth::load_auth_dot_json;
 use codex_login::ServerOptions;
 use codex_login::run_device_code_login;
 use serde_json::json;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicUsize;
 use std::sync::atomic::Ordering;
 use tempfile::tempdir;
diff --git a/codex-rs/mcp-server/src/codex_tool_config.rs b/codex-rs/mcp-server/src/codex_tool_config.rs
index 4e61bde0..a40a12ef 100644
--- a/codex-rs/mcp-server/src/codex_tool_config.rs
+++ b/codex-rs/mcp-server/src/codex_tool_config.rs
@@ -10,7 +10,58 @@ use schemars::r#gen::SchemaSettings;
 use serde::Deserialize;
 use serde::Serialize;
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 /// Client-supplied configuration for a `codex` tool-call.
 #[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
diff --git a/codex-rs/mcp-server/src/codex_tool_runner.rs b/codex-rs/mcp-server/src/codex_tool_runner.rs
index 93dc7764..05e761ae 100644
--- a/codex-rs/mcp-server/src/codex_tool_runner.rs
+++ b/codex-rs/mcp-server/src/codex_tool_runner.rs
@@ -3,7 +3,58 @@
 //! and to make future feature-growth easier to manage.
 
 use std::collections::HashMap;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::sync::{Arc, OnceLock};
 
 use crate::exec_approval::handle_exec_approval_request;
 use crate::outgoing_message::OutgoingMessageSender;
diff --git a/codex-rs/mcp-server/src/exec_approval.rs b/codex-rs/mcp-server/src/exec_approval.rs
index 033523ac..022db304 100644
--- a/codex-rs/mcp-server/src/exec_approval.rs
+++ b/codex-rs/mcp-server/src/exec_approval.rs
@@ -1,5 +1,5 @@
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 
 use codex_core::CodexConversation;
 use codex_core::protocol::Op;
diff --git a/codex-rs/mcp-server/src/lib.rs b/codex-rs/mcp-server/src/lib.rs
index 8da5b405..c36fbfbe 100644
--- a/codex-rs/mcp-server/src/lib.rs
+++ b/codex-rs/mcp-server/src/lib.rs
@@ -3,7 +3,7 @@
 
 use std::io::ErrorKind;
 use std::io::Result as IoResult;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_common::CliConfigOverrides;
 use codex_core::config::Config;
diff --git a/codex-rs/mcp-server/src/message_processor.rs b/codex-rs/mcp-server/src/message_processor.rs
index 81eb8076..cb428834 100644
--- a/codex-rs/mcp-server/src/message_processor.rs
+++ b/codex-rs/mcp-server/src/message_processor.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 use crate::codex_tool_config::CodexToolCallParam;
 use crate::codex_tool_config::CodexToolCallReplyParam;
@@ -32,7 +83,7 @@ use mcp_types::ServerCapabilitiesTools;
 use mcp_types::ServerNotification;
 use mcp_types::TextContent;
 use serde_json::json;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use tokio::sync::Mutex;
 use tokio::task;
 
diff --git a/codex-rs/mcp-server/src/outgoing_message.rs b/codex-rs/mcp-server/src/outgoing_message.rs
index 4b6782d8..adf015e2 100644
--- a/codex-rs/mcp-server/src/outgoing_message.rs
+++ b/codex-rs/mcp-server/src/outgoing_message.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::sync::atomic::AtomicI64;
 use std::sync::atomic::Ordering;
 
@@ -18,6 +69,52 @@ use tokio::sync::mpsc;
 use tokio::sync::oneshot;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::error_code::INTERNAL_ERROR_CODE;
 
 /// Sends messages to the client and manages request callbacks.
diff --git a/codex-rs/mcp-server/src/patch_approval.rs b/codex-rs/mcp-server/src/patch_approval.rs
index 3c614ab3..01c20443 100644
--- a/codex-rs/mcp-server/src/patch_approval.rs
+++ b/codex-rs/mcp-server/src/patch_approval.rs
@@ -1,6 +1,57 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 
 use codex_core::CodexConversation;
 use codex_core::protocol::FileChange;
diff --git a/codex-rs/mcp-server/tests/suite/codex_tool.rs b/codex-rs/mcp-server/tests/suite/codex_tool.rs
index ae0c23f1..f9212d42 100644
--- a/codex-rs/mcp-server/tests/suite/codex_tool.rs
+++ b/codex-rs/mcp-server/tests/suite/codex_tool.rs
@@ -1,7 +1,58 @@
 use std::collections::HashMap;
 use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::env;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::parse_command;
 use codex_core::protocol::FileChange;
diff --git a/codex-rs/ollama/src/pull.rs b/codex-rs/ollama/src/pull.rs
index 0dd35cd7..b214f793 100644
--- a/codex-rs/ollama/src/pull.rs
+++ b/codex-rs/ollama/src/pull.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::io;
 use std::io::Write;
 
diff --git a/codex-rs/otel/src/config.rs b/codex-rs/otel/src/config.rs
index 77063ed0..b3abc1b5 100644
--- a/codex-rs/otel/src/config.rs
+++ b/codex-rs/otel/src/config.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 #[derive(Clone, Debug)]
 pub struct OtelSettings {
diff --git a/codex-rs/otel/src/otel_event_manager.rs b/codex-rs/otel/src/otel_event_manager.rs
index 5d9cbd49..d325c079 100644
--- a/codex-rs/otel/src/otel_event_manager.rs
+++ b/codex-rs/otel/src/otel_event_manager.rs
@@ -18,6 +18,7 @@ use serde::Serialize;
 use std::borrow::Cow;
 use std::fmt::Display;
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 use strum_macros::Display;
 use tokio::time::error::Elapsed;
diff --git a/codex-rs/protocol/src/approvals.rs b/codex-rs/protocol/src/approvals.rs
index f7c5fc60..119d6076 100644
--- a/codex-rs/protocol/src/approvals.rs
+++ b/codex-rs/protocol/src/approvals.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 use crate::parse_command::ParsedCommand;
 use crate::protocol::FileChange;
diff --git a/codex-rs/protocol/src/custom_prompts.rs b/codex-rs/protocol/src/custom_prompts.rs
index 7472d1b4..221bbe6e 100644
--- a/codex-rs/protocol/src/custom_prompts.rs
+++ b/codex-rs/protocol/src/custom_prompts.rs
@@ -1,7 +1,7 @@
 use schemars::JsonSchema;
 use serde::Deserialize;
 use serde::Serialize;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use ts_rs::TS;
 
 /// Base namespace for custom prompt slash commands (without trailing colon).
diff --git a/codex-rs/protocol/src/models.rs b/codex-rs/protocol/src/models.rs
index e97000c5..71e0d79c 100644
--- a/codex-rs/protocol/src/models.rs
+++ b/codex-rs/protocol/src/models.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 use base64::Engine;
 use codex_utils_image::load_and_resize_to_fit;
diff --git a/codex-rs/protocol/src/parse_command.rs b/codex-rs/protocol/src/parse_command.rs
index 77926f11..cdcff546 100644
--- a/codex-rs/protocol/src/parse_command.rs
+++ b/codex-rs/protocol/src/parse_command.rs
@@ -1,7 +1,7 @@
 use schemars::JsonSchema;
 use serde::Deserialize;
 use serde::Serialize;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use ts_rs::TS;
 
 #[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize, JsonSchema, TS)]
diff --git a/codex-rs/protocol/src/protocol.rs b/codex-rs/protocol/src/protocol.rs
index 553f6437..2c98dfc0 100644
--- a/codex-rs/protocol/src/protocol.rs
+++ b/codex-rs/protocol/src/protocol.rs
@@ -4,9 +4,60 @@
 //! between user and agent.
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::fmt;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::str::FromStr;
 use std::time::Duration;
 
diff --git a/codex-rs/responses-api-proxy/src/lib.rs b/codex-rs/responses-api-proxy/src/lib.rs
index bbe0484d..845fda23 100644
--- a/codex-rs/responses-api-proxy/src/lib.rs
+++ b/codex-rs/responses-api-proxy/src/lib.rs
@@ -4,8 +4,8 @@ use std::io::Write;
 use std::net::SocketAddr;
 use std::net::TcpListener;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use anyhow::Context;
diff --git a/codex-rs/rmcp-client/src/auth_status.rs b/codex-rs/rmcp-client/src/auth_status.rs
index 77c33f69..918e55c2 100644
--- a/codex-rs/rmcp-client/src/auth_status.rs
+++ b/codex-rs/rmcp-client/src/auth_status.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::time::Duration;
 
 use anyhow::Error;
diff --git a/codex-rs/rmcp-client/src/bin/rmcp_test_server.rs b/codex-rs/rmcp-client/src/bin/rmcp_test_server.rs
index 23b2f93b..95be5f53 100644
--- a/codex-rs/rmcp-client/src/bin/rmcp_test_server.rs
+++ b/codex-rs/rmcp-client/src/bin/rmcp_test_server.rs
@@ -1,6 +1,57 @@
 use std::borrow::Cow;
 use std::collections::HashMap;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::sync::{Arc, OnceLock};
 
 use rmcp::ErrorData as McpError;
 use rmcp::ServiceExt;
diff --git a/codex-rs/rmcp-client/src/bin/test_stdio_server.rs b/codex-rs/rmcp-client/src/bin/test_stdio_server.rs
index aafba593..47c84a1f 100644
--- a/codex-rs/rmcp-client/src/bin/test_stdio_server.rs
+++ b/codex-rs/rmcp-client/src/bin/test_stdio_server.rs
@@ -1,6 +1,57 @@
 use std::borrow::Cow;
 use std::collections::HashMap;
-use std::sync::Arc;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::sync::{Arc, OnceLock};
 
 use rmcp::ErrorData as McpError;
 use rmcp::ServiceExt;
diff --git a/codex-rs/rmcp-client/src/bin/test_streamable_http_server.rs b/codex-rs/rmcp-client/src/bin/test_streamable_http_server.rs
index f56a8582..bb583507 100644
--- a/codex-rs/rmcp-client/src/bin/test_streamable_http_server.rs
+++ b/codex-rs/rmcp-client/src/bin/test_streamable_http_server.rs
@@ -1,8 +1,59 @@
 use std::borrow::Cow;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::io::ErrorKind;
 use std::net::SocketAddr;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use axum::Router;
 use axum::body::Body;
diff --git a/codex-rs/rmcp-client/src/find_codex_home.rs b/codex-rs/rmcp-client/src/find_codex_home.rs
index d683ba9d..5b2a48e8 100644
--- a/codex-rs/rmcp-client/src/find_codex_home.rs
+++ b/codex-rs/rmcp-client/src/find_codex_home.rs
@@ -1,5 +1,5 @@
 use dirs::home_dir;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 /// This was copied from codex-core but codex-core depends on this crate.
 /// TODO: move this to a shared crate lower in the dependency tree.
diff --git a/codex-rs/rmcp-client/src/logging_client_handler.rs b/codex-rs/rmcp-client/src/logging_client_handler.rs
index 85d237b0..358499d5 100644
--- a/codex-rs/rmcp-client/src/logging_client_handler.rs
+++ b/codex-rs/rmcp-client/src/logging_client_handler.rs
@@ -16,6 +16,52 @@ use tracing::error;
 use tracing::info;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 #[derive(Debug, Clone)]
 pub(crate) struct LoggingClientHandler {
     client_info: ClientInfo,
diff --git a/codex-rs/rmcp-client/src/oauth.rs b/codex-rs/rmcp-client/src/oauth.rs
index bd6833fc..b0fba390 100644
--- a/codex-rs/rmcp-client/src/oauth.rs
+++ b/codex-rs/rmcp-client/src/oauth.rs
@@ -35,13 +35,59 @@ use sha2::Sha256;
 use std::collections::BTreeMap;
 use std::fs;
 use std::io::ErrorKind;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 use std::time::SystemTime;
 use std::time::UNIX_EPOCH;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use codex_keyring_store::DefaultKeyringStore;
 use codex_keyring_store::KeyringStore;
 use rmcp::transport::auth::AuthorizationManager;
diff --git a/codex-rs/rmcp-client/src/perform_oauth_login.rs b/codex-rs/rmcp-client/src/perform_oauth_login.rs
index 425e124d..ea9eea4e 100644
--- a/codex-rs/rmcp-client/src/perform_oauth_login.rs
+++ b/codex-rs/rmcp-client/src/perform_oauth_login.rs
@@ -1,6 +1,57 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::string::String;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use anyhow::Context;
diff --git a/codex-rs/rmcp-client/src/program_resolver.rs b/codex-rs/rmcp-client/src/program_resolver.rs
index e62336e2..c9852924 100644
--- a/codex-rs/rmcp-client/src/program_resolver.rs
+++ b/codex-rs/rmcp-client/src/program_resolver.rs
@@ -11,6 +11,57 @@
 //! - On Windows: Uses the `which` crate to resolve full paths including extensions
 
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::ffi::OsString;
 
 #[cfg(windows)]
diff --git a/codex-rs/rmcp-client/src/rmcp_client.rs b/codex-rs/rmcp-client/src/rmcp_client.rs
index f21859dc..72f9da1d 100644
--- a/codex-rs/rmcp-client/src/rmcp_client.rs
+++ b/codex-rs/rmcp-client/src/rmcp_client.rs
@@ -1,9 +1,60 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::ffi::OsString;
 use std::io;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process::Stdio;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use anyhow::Result;
@@ -42,6 +93,52 @@ use tokio::time;
 use tracing::info;
 use tracing::warn;
 
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+
 use crate::load_oauth_tokens;
 use crate::logging_client_handler::LoggingClientHandler;
 use crate::oauth::OAuthCredentialsStoreMode;
diff --git a/codex-rs/rmcp-client/src/utils.rs b/codex-rs/rmcp-client/src/utils.rs
index 8deb4d40..8ae7fc06 100644
--- a/codex-rs/rmcp-client/src/utils.rs
+++ b/codex-rs/rmcp-client/src/utils.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
 use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::env;
 use std::time::Duration;
 
 use anyhow::Context;
diff --git a/codex-rs/rmcp-client/tests/resources.rs b/codex-rs/rmcp-client/tests/resources.rs
index 2117f9b1..d3428422 100644
--- a/codex-rs/rmcp-client/tests/resources.rs
+++ b/codex-rs/rmcp-client/tests/resources.rs
@@ -1,5 +1,5 @@
 use std::ffi::OsString;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::time::Duration;
 
 use codex_rmcp_client::RmcpClient;
diff --git a/codex-rs/stdio-to-uds/src/main.rs b/codex-rs/stdio-to-uds/src/main.rs
index 69987c31..883cb544 100644
--- a/codex-rs/stdio-to-uds/src/main.rs
+++ b/codex-rs/stdio-to-uds/src/main.rs
@@ -1,5 +1,5 @@
 use std::env;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process;
 
 fn main() -> anyhow::Result<()> {
diff --git a/codex-rs/tui/src/additional_dirs.rs b/codex-rs/tui/src/additional_dirs.rs
index cc43f329..968b0d19 100644
--- a/codex-rs/tui/src/additional_dirs.rs
+++ b/codex-rs/tui/src/additional_dirs.rs
@@ -1,5 +1,5 @@
 use codex_core::protocol::SandboxPolicy;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 /// Returns a warning describing why `--add-dir` entries will be ignored for the
 /// resolved sandbox policy. The caller is responsible for presenting the
@@ -34,7 +34,7 @@ mod tests {
     use super::add_dir_warning_message;
     use codex_core::protocol::SandboxPolicy;
     use pretty_assertions::assert_eq;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
 
     #[test]
     fn returns_none_for_workspace_write() {
diff --git a/codex-rs/tui/src/app.rs b/codex-rs/tui/src/app.rs
index 9f996007..ea5b0f32 100644
--- a/codex-rs/tui/src/app.rs
+++ b/codex-rs/tui/src/app.rs
@@ -36,8 +36,8 @@ use crossterm::event::KeyEvent;
 use crossterm::event::KeyEventKind;
 use ratatui::style::Stylize;
 use ratatui::text::Line;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicBool;
 use std::sync::atomic::Ordering;
 use std::thread;
@@ -861,8 +861,8 @@ mod tests {
     use codex_core::protocol::SessionConfiguredEvent;
     use codex_protocol::ConversationId;
     use ratatui::prelude::Line;
-    use std::path::PathBuf;
-    use std::sync::Arc;
+    use std::path::{Path, PathBuf};
+    use std::sync::{Arc, OnceLock};
     use std::sync::atomic::AtomicBool;
 
     fn make_test_app() -> App {
diff --git a/codex-rs/tui/src/app_backtrack.rs b/codex-rs/tui/src/app_backtrack.rs
index b161867e..001466d4 100644
--- a/codex-rs/tui/src/app_backtrack.rs
+++ b/codex-rs/tui/src/app_backtrack.rs
@@ -1,6 +1,6 @@
 use std::any::TypeId;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 
 use crate::app::App;
 use crate::history_cell::SessionInfoCell;
@@ -416,7 +416,7 @@ mod tests {
     use crate::history_cell::AgentMessageCell;
     use crate::history_cell::HistoryCell;
     use ratatui::prelude::Line;
-    use std::sync::Arc;
+    use std::sync::{Arc, OnceLock};
 
     #[test]
     fn trim_transcript_for_first_user_drops_user_and_newer_cells() {
diff --git a/codex-rs/tui/src/app_event.rs b/codex-rs/tui/src/app_event.rs
index 0c3033c5..83cf465a 100644
--- a/codex-rs/tui/src/app_event.rs
+++ b/codex-rs/tui/src/app_event.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_common::approval_presets::ApprovalPreset;
 use codex_common::model_presets::ModelPreset;
diff --git a/codex-rs/tui/src/ascii_animation.rs b/codex-rs/tui/src/ascii_animation.rs
index b2d9fc1d..b46eb4d5 100644
--- a/codex-rs/tui/src/ascii_animation.rs
+++ b/codex-rs/tui/src/ascii_animation.rs
@@ -1,5 +1,6 @@
 use std::convert::TryFrom;
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use rand::Rng as _;
diff --git a/codex-rs/tui/src/bottom_pane/approval_overlay.rs b/codex-rs/tui/src/bottom_pane/approval_overlay.rs
index ef709f00..d501cfb4 100644
--- a/codex-rs/tui/src/bottom_pane/approval_overlay.rs
+++ b/codex-rs/tui/src/bottom_pane/approval_overlay.rs
@@ -1,5 +1,56 @@
 use std::collections::HashMap;
-use std::path::PathBuf;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::path::{Path, PathBuf};
 
 use crate::app_event::AppEvent;
 use crate::app_event_sender::AppEventSender;
diff --git a/codex-rs/tui/src/bottom_pane/chat_composer.rs b/codex-rs/tui/src/bottom_pane/chat_composer.rs
index f64a824f..32a09712 100644
--- a/codex-rs/tui/src/bottom_pane/chat_composer.rs
+++ b/codex-rs/tui/src/bottom_pane/chat_composer.rs
@@ -56,9 +56,61 @@ use crate::ui_consts::LIVE_PREFIX_COLS;
 use codex_file_search::FileMatch;
 use std::cell::RefCell;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 /// If the pasted content exceeds this number of characters, replace it with a
@@ -1684,7 +1736,7 @@ mod tests {
     use image::ImageBuffer;
     use image::Rgba;
     use pretty_assertions::assert_eq;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use tempfile::tempdir;
 
     use crate::app_event::AppEvent;
diff --git a/codex-rs/tui/src/bottom_pane/chat_composer_history.rs b/codex-rs/tui/src/bottom_pane/chat_composer_history.rs
index 991283a5..dbc6ddf5 100644
--- a/codex-rs/tui/src/bottom_pane/chat_composer_history.rs
+++ b/codex-rs/tui/src/bottom_pane/chat_composer_history.rs
@@ -1,4 +1,55 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 
 use crate::app_event::AppEvent;
 use crate::app_event_sender::AppEventSender;
diff --git a/codex-rs/tui/src/bottom_pane/feedback_view.rs b/codex-rs/tui/src/bottom_pane/feedback_view.rs
index a8476df0..8f49fbba 100644
--- a/codex-rs/tui/src/bottom_pane/feedback_view.rs
+++ b/codex-rs/tui/src/bottom_pane/feedback_view.rs
@@ -1,5 +1,5 @@
 use std::cell::RefCell;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crossterm::event::KeyCode;
 use crossterm::event::KeyEvent;
diff --git a/codex-rs/tui/src/bottom_pane/mod.rs b/codex-rs/tui/src/bottom_pane/mod.rs
index da2efb63..11aa9d7b 100644
--- a/codex-rs/tui/src/bottom_pane/mod.rs
+++ b/codex-rs/tui/src/bottom_pane/mod.rs
@@ -1,5 +1,5 @@
 //! Bottom pane: shows the ChatComposer or a BottomPaneView, if one is active.
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::app_event_sender::AppEventSender;
 use crate::bottom_pane::queued_user_messages::QueuedUserMessages;
diff --git a/codex-rs/tui/src/bottom_pane/paste_burst.rs b/codex-rs/tui/src/bottom_pane/paste_burst.rs
index 49377cb2..1f609fa0 100644
--- a/codex-rs/tui/src/bottom_pane/paste_burst.rs
+++ b/codex-rs/tui/src/bottom_pane/paste_burst.rs
@@ -1,4 +1,5 @@
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 // Heuristic thresholds for detecting paste-like input bursts.
diff --git a/codex-rs/tui/src/bottom_pane/prompt_args.rs b/codex-rs/tui/src/bottom_pane/prompt_args.rs
index 48c3cedf..08916cf4 100644
--- a/codex-rs/tui/src/bottom_pane/prompt_args.rs
+++ b/codex-rs/tui/src/bottom_pane/prompt_args.rs
@@ -4,6 +4,57 @@ use lazy_static::lazy_static;
 use regex_lite::Regex;
 use shlex::Shlex;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::collections::HashSet;
 
 lazy_static! {
diff --git a/codex-rs/tui/src/chatwidget.rs b/codex-rs/tui/src/chatwidget.rs
index cdcc78ab..c8304d30 100644
--- a/codex-rs/tui/src/chatwidget.rs
+++ b/codex-rs/tui/src/chatwidget.rs
@@ -1,7 +1,58 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::collections::VecDeque;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use codex_app_server_protocol::AuthMode;
@@ -1425,6 +1476,57 @@ impl ChatWidget {
             SlashCommand::TestApproval => {
                 use codex_core::protocol::EventMsg;
                 use std::collections::HashMap;
+                use std::env;
+                use std::fs::OpenOptions;
+                use std::io::Write;
+                use serde_json::json;
+                use tracing::warn;
+                
+                static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+                
+                fn event_trace_path() -> Option<&'static PathBuf> {
+                    EVENT_TRACE_PATH
+                        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                            Some(path) if !path.is_empty() => {
+                                let file = PathBuf::from(path);
+                                if let Some(parent) = file.parent() {
+                                    if let Err(err) = std::fs::create_dir_all(parent) {
+                                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                                        return None;
+                                    }
+                                }
+                                Some(file)
+                            }
+                            _ => None,
+                        })
+                        .as_ref()
+                }
+                
+                fn log_event_for_hypebrut(event: &Event) {
+                    let Some(path) = event_trace_path() else {
+                        return;
+                    };
+                
+                    let timestamp = SystemTime::now()
+                        .duration_since(UNIX_EPOCH)
+                        .unwrap_or_default()
+                        .as_secs_f64();
+                
+                    let payload = serde_json::json!({
+                        \"ts\": timestamp,
+                        \"event\": event,
+                    });
+                
+                    if let Err(err) = append_event_line(path, payload.to_string()) {
+                        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+                    }
+                }
+                
+                fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+                    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+                    file.write_all(line.as_bytes())?;
+                    file.write_all(b\"\\n\")
+                }
 
                 use codex_core::protocol::ApplyPatchApprovalRequestEvent;
                 use codex_core::protocol::FileChange;
@@ -2330,6 +2432,57 @@ impl ChatWidget {
     #[cfg(target_os = "windows")]
     fn windows_world_writable_flagged(&self) -> bool {
         use std::collections::HashMap;
+        use std::env;
+        use std::fs::OpenOptions;
+        use std::io::Write;
+        use serde_json::json;
+        use tracing::warn;
+        
+        static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+        
+        fn event_trace_path() -> Option<&'static PathBuf> {
+            EVENT_TRACE_PATH
+                .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                    Some(path) if !path.is_empty() => {
+                        let file = PathBuf::from(path);
+                        if let Some(parent) = file.parent() {
+                            if let Err(err) = std::fs::create_dir_all(parent) {
+                                warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                                return None;
+                            }
+                        }
+                        Some(file)
+                    }
+                    _ => None,
+                })
+                .as_ref()
+        }
+        
+        fn log_event_for_hypebrut(event: &Event) {
+            let Some(path) = event_trace_path() else {
+                return;
+            };
+        
+            let timestamp = SystemTime::now()
+                .duration_since(UNIX_EPOCH)
+                .unwrap_or_default()
+                .as_secs_f64();
+        
+            let payload = serde_json::json!({
+                \"ts\": timestamp,
+                \"event\": event,
+            });
+        
+            if let Err(err) = append_event_line(path, payload.to_string()) {
+                warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+            }
+        }
+        
+        fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+            let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+            file.write_all(line.as_bytes())?;
+            file.write_all(b\"\\n\")
+        }
         let mut env_map: HashMap<String, String> = HashMap::new();
         for (k, v) in std::env::vars() {
             env_map.insert(k, v);
diff --git a/codex-rs/tui/src/chatwidget/agent.rs b/codex-rs/tui/src/chatwidget/agent.rs
index bf15b6c4..36841859 100644
--- a/codex-rs/tui/src/chatwidget/agent.rs
+++ b/codex-rs/tui/src/chatwidget/agent.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use codex_core::CodexConversation;
 use codex_core::ConversationManager;
diff --git a/codex-rs/tui/src/chatwidget/tests.rs b/codex-rs/tui/src/chatwidget/tests.rs
index abd9a612..e66da42f 100644
--- a/codex-rs/tui/src/chatwidget/tests.rs
+++ b/codex-rs/tui/src/chatwidget/tests.rs
@@ -52,7 +52,7 @@ use crossterm::event::KeyEvent;
 use crossterm::event::KeyModifiers;
 use insta::assert_snapshot;
 use pretty_assertions::assert_eq;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tempfile::NamedTempFile;
 use tempfile::tempdir;
 use tokio::sync::mpsc::error::TryRecvError;
diff --git a/codex-rs/tui/src/cli.rs b/codex-rs/tui/src/cli.rs
index e7a0c945..f623276c 100644
--- a/codex-rs/tui/src/cli.rs
+++ b/codex-rs/tui/src/cli.rs
@@ -2,7 +2,7 @@ use clap::Parser;
 use clap::ValueHint;
 use codex_common::ApprovalModeCliArg;
 use codex_common::CliConfigOverrides;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Parser, Debug)]
 #[command(version)]
diff --git a/codex-rs/tui/src/clipboard_paste.rs b/codex-rs/tui/src/clipboard_paste.rs
index 4945eea3..1348b32f 100644
--- a/codex-rs/tui/src/clipboard_paste.rs
+++ b/codex-rs/tui/src/clipboard_paste.rs
@@ -1,5 +1,5 @@
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tempfile::Builder;
 
 #[derive(Debug)]
diff --git a/codex-rs/tui/src/diff_render.rs b/codex-rs/tui/src/diff_render.rs
index 24c5be59..31f76964 100644
--- a/codex-rs/tui/src/diff_render.rs
+++ b/codex-rs/tui/src/diff_render.rs
@@ -9,8 +9,59 @@ use ratatui::text::Line as RtLine;
 use ratatui::text::Span as RtSpan;
 use ratatui::widgets::Paragraph;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::exec_command::relativize_to_home;
 use crate::render::Insets;
diff --git a/codex-rs/tui/src/exec_cell/model.rs b/codex-rs/tui/src/exec_cell/model.rs
index 943fb836..e74359d1 100644
--- a/codex-rs/tui/src/exec_cell/model.rs
+++ b/codex-rs/tui/src/exec_cell/model.rs
@@ -1,4 +1,5 @@
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use codex_core::protocol::ExecCommandSource;
diff --git a/codex-rs/tui/src/exec_cell/render.rs b/codex-rs/tui/src/exec_cell/render.rs
index 352a6147..64f55b3a 100644
--- a/codex-rs/tui/src/exec_cell/render.rs
+++ b/codex-rs/tui/src/exec_cell/render.rs
@@ -1,3 +1,4 @@
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use super::model::CommandOutput;
diff --git a/codex-rs/tui/src/exec_command.rs b/codex-rs/tui/src/exec_command.rs
index 6f2212b0..ad235080 100644
--- a/codex-rs/tui/src/exec_command.rs
+++ b/codex-rs/tui/src/exec_command.rs
@@ -1,5 +1,5 @@
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::bash::extract_bash_command;
 use dirs::home_dir;
diff --git a/codex-rs/tui/src/file_search.rs b/codex-rs/tui/src/file_search.rs
index 61327cfd..76e37052 100644
--- a/codex-rs/tui/src/file_search.rs
+++ b/codex-rs/tui/src/file_search.rs
@@ -20,8 +20,8 @@
 
 use codex_file_search as file_search;
 use std::num::NonZeroUsize;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 use std::sync::Mutex;
 use std::sync::atomic::AtomicBool;
 use std::sync::atomic::Ordering;
diff --git a/codex-rs/tui/src/history_cell.rs b/codex-rs/tui/src/history_cell.rs
index b026170f..70636edd 100644
--- a/codex-rs/tui/src/history_cell.rs
+++ b/codex-rs/tui/src/history_cell.rs
@@ -49,10 +49,62 @@ use ratatui::widgets::Paragraph;
 use ratatui::widgets::Wrap;
 use std::any::Any;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::io::Cursor;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 use tracing::error;
 use unicode_width::UnicodeWidthStr;
@@ -1475,6 +1527,57 @@ mod tests {
     use pretty_assertions::assert_eq;
     use serde_json::json;
     use std::collections::HashMap;
+    use std::env;
+    use std::fs::OpenOptions;
+    use std::io::Write;
+    use serde_json::json;
+    use tracing::warn;
+    
+    static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+    
+    fn event_trace_path() -> Option<&'static PathBuf> {
+        EVENT_TRACE_PATH
+            .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                Some(path) if !path.is_empty() => {
+                    let file = PathBuf::from(path);
+                    if let Some(parent) = file.parent() {
+                        if let Err(err) = std::fs::create_dir_all(parent) {
+                            warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                            return None;
+                        }
+                    }
+                    Some(file)
+                }
+                _ => None,
+            })
+            .as_ref()
+    }
+    
+    fn log_event_for_hypebrut(event: &Event) {
+        let Some(path) = event_trace_path() else {
+            return;
+        };
+    
+        let timestamp = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_default()
+            .as_secs_f64();
+    
+        let payload = serde_json::json!({
+            \"ts\": timestamp,
+            \"event\": event,
+        });
+    
+        if let Err(err) = append_event_line(path, payload.to_string()) {
+            warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+        }
+    }
+    
+    fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+        let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+        file.write_all(line.as_bytes())?;
+        file.write_all(b\"\\n\")
+    }
 
     use codex_core::protocol::ExecCommandSource;
     use mcp_types::CallToolResult;
diff --git a/codex-rs/tui/src/lib.rs b/codex-rs/tui/src/lib.rs
index ca7cba9c..55dc0913 100644
--- a/codex-rs/tui/src/lib.rs
+++ b/codex-rs/tui/src/lib.rs
@@ -25,7 +25,7 @@ use codex_core::protocol::AskForApproval;
 use codex_protocol::config_types::SandboxMode;
 use opentelemetry_appender_tracing::layer::OpenTelemetryTracingBridge;
 use std::fs::OpenOptions;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tracing::error;
 use tracing_appender::non_blocking;
 use tracing_subscriber::EnvFilter;
diff --git a/codex-rs/tui/src/onboarding/auth.rs b/codex-rs/tui/src/onboarding/auth.rs
index 06e1c629..3065743e 100644
--- a/codex-rs/tui/src/onboarding/auth.rs
+++ b/codex-rs/tui/src/onboarding/auth.rs
@@ -38,8 +38,8 @@ use crate::onboarding::onboarding_screen::KeyboardHandler;
 use crate::onboarding::onboarding_screen::StepStateProvider;
 use crate::shimmer::shimmer_spans;
 use crate::tui::FrameRequester;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 
 use super::onboarding_screen::StepState;
 
diff --git a/codex-rs/tui/src/onboarding/onboarding_screen.rs b/codex-rs/tui/src/onboarding/onboarding_screen.rs
index 02c7be7a..28a3c882 100644
--- a/codex-rs/tui/src/onboarding/onboarding_screen.rs
+++ b/codex-rs/tui/src/onboarding/onboarding_screen.rs
@@ -25,7 +25,7 @@ use crate::tui::FrameRequester;
 use crate::tui::Tui;
 use crate::tui::TuiEvent;
 use color_eyre::eyre::Result;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::RwLock;
 
 #[allow(clippy::large_enum_variant)]
diff --git a/codex-rs/tui/src/onboarding/trust_directory.rs b/codex-rs/tui/src/onboarding/trust_directory.rs
index fd24b8e8..56d7f189 100644
--- a/codex-rs/tui/src/onboarding/trust_directory.rs
+++ b/codex-rs/tui/src/onboarding/trust_directory.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::config::set_project_trust_level;
 use codex_core::git_info::resolve_root_git_project_for_trust;
@@ -190,7 +190,7 @@ mod tests {
     use pretty_assertions::assert_eq;
     use ratatui::Terminal;
 
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
 
     #[test]
     fn release_event_does_not_change_selection() {
diff --git a/codex-rs/tui/src/onboarding/windows.rs b/codex-rs/tui/src/onboarding/windows.rs
index 715611b7..2cd34d62 100644
--- a/codex-rs/tui/src/onboarding/windows.rs
+++ b/codex-rs/tui/src/onboarding/windows.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use codex_core::config::edit::ConfigEditsBuilder;
 use crossterm::event::KeyCode;
diff --git a/codex-rs/tui/src/pager_overlay.rs b/codex-rs/tui/src/pager_overlay.rs
index 6393a754..6bbc14f4 100644
--- a/codex-rs/tui/src/pager_overlay.rs
+++ b/codex-rs/tui/src/pager_overlay.rs
@@ -1,5 +1,5 @@
 use std::io::Result;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::time::Duration;
 
 use crate::history_cell::HistoryCell;
@@ -583,8 +583,59 @@ mod tests {
     use codex_core::protocol::ReviewDecision;
     use insta::assert_snapshot;
     use std::collections::HashMap;
-    use std::path::PathBuf;
-    use std::sync::Arc;
+    use std::env;
+    use std::fs::OpenOptions;
+    use std::io::Write;
+    use serde_json::json;
+    use tracing::warn;
+    
+    static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+    
+    fn event_trace_path() -> Option<&'static PathBuf> {
+        EVENT_TRACE_PATH
+            .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                Some(path) if !path.is_empty() => {
+                    let file = PathBuf::from(path);
+                    if let Some(parent) = file.parent() {
+                        if let Err(err) = std::fs::create_dir_all(parent) {
+                            warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                            return None;
+                        }
+                    }
+                    Some(file)
+                }
+                _ => None,
+            })
+            .as_ref()
+    }
+    
+    fn log_event_for_hypebrut(event: &Event) {
+        let Some(path) = event_trace_path() else {
+            return;
+        };
+    
+        let timestamp = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_default()
+            .as_secs_f64();
+    
+        let payload = serde_json::json!({
+            \"ts\": timestamp,
+            \"event\": event,
+        });
+    
+        if let Err(err) = append_event_line(path, payload.to_string()) {
+            warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+        }
+    }
+    
+    fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+        let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+        file.write_all(line.as_bytes())?;
+        file.write_all(b\"\\n\")
+    }
+    use std::path::{Path, PathBuf};
+    use std::sync::{Arc, OnceLock};
     use std::time::Duration;
 
     use crate::exec_cell::CommandOutput;
diff --git a/codex-rs/tui/src/render/renderable.rs b/codex-rs/tui/src/render/renderable.rs
index 8581468c..4a5ca1ee 100644
--- a/codex-rs/tui/src/render/renderable.rs
+++ b/codex-rs/tui/src/render/renderable.rs
@@ -1,4 +1,4 @@
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use ratatui::buffer::Buffer;
 use ratatui::layout::Rect;
diff --git a/codex-rs/tui/src/resume_picker.rs b/codex-rs/tui/src/resume_picker.rs
index 83e3a1ae..57da233c 100644
--- a/codex-rs/tui/src/resume_picker.rs
+++ b/codex-rs/tui/src/resume_picker.rs
@@ -1,7 +1,7 @@
 use std::collections::HashSet;
 use std::path::Path;
-use std::path::PathBuf;
-use std::sync::Arc;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, OnceLock};
 
 use chrono::DateTime;
 use chrono::Utc;
@@ -926,8 +926,8 @@ mod tests {
     use insta::assert_snapshot;
     use serde_json::json;
     use std::future::Future;
-    use std::path::PathBuf;
-    use std::sync::Arc;
+    use std::path::{Path, PathBuf};
+    use std::sync::{Arc, OnceLock};
     use std::sync::Mutex;
 
     fn head_with_ts_and_user_text(ts: &str, texts: &[&str]) -> Vec<serde_json::Value> {
diff --git a/codex-rs/tui/src/session_log.rs b/codex-rs/tui/src/session_log.rs
index b2858e8f..18743002 100644
--- a/codex-rs/tui/src/session_log.rs
+++ b/codex-rs/tui/src/session_log.rs
@@ -1,7 +1,7 @@
 use std::fs::File;
 use std::fs::OpenOptions;
 use std::io::Write;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::sync::LazyLock;
 use std::sync::Mutex;
 use std::sync::OnceLock;
diff --git a/codex-rs/tui/src/shimmer.rs b/codex-rs/tui/src/shimmer.rs
index ba081e7c..f320f35b 100644
--- a/codex-rs/tui/src/shimmer.rs
+++ b/codex-rs/tui/src/shimmer.rs
@@ -1,5 +1,6 @@
 use std::sync::OnceLock;
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use ratatui::style::Color;
diff --git a/codex-rs/tui/src/status/card.rs b/codex-rs/tui/src/status/card.rs
index be10eb56..963ca80f 100644
--- a/codex-rs/tui/src/status/card.rs
+++ b/codex-rs/tui/src/status/card.rs
@@ -13,7 +13,7 @@ use codex_protocol::ConversationId;
 use ratatui::prelude::*;
 use ratatui::style::Stylize;
 use std::collections::BTreeSet;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use super::account::StatusAccountDisplay;
 use super::format::FieldFormatter;
diff --git a/codex-rs/tui/src/status/tests.rs b/codex-rs/tui/src/status/tests.rs
index 5120e36f..a00db414 100644
--- a/codex-rs/tui/src/status/tests.rs
+++ b/codex-rs/tui/src/status/tests.rs
@@ -16,7 +16,7 @@ use codex_protocol::config_types::ReasoningEffort;
 use codex_protocol::config_types::ReasoningSummary;
 use insta::assert_snapshot;
 use ratatui::prelude::*;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use tempfile::TempDir;
 
 fn test_config(temp_home: &TempDir) -> Config {
diff --git a/codex-rs/tui/src/status_indicator_widget.rs b/codex-rs/tui/src/status_indicator_widget.rs
index 54979e6d..24229429 100644
--- a/codex-rs/tui/src/status_indicator_widget.rs
+++ b/codex-rs/tui/src/status_indicator_widget.rs
@@ -2,6 +2,7 @@
 //! application while the agent is processing a longrunning task.
 
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use codex_core::protocol::Op;
@@ -172,6 +173,7 @@ mod tests {
     use ratatui::Terminal;
     use ratatui::backend::TestBackend;
     use std::time::Duration;
+    use std::sync::OnceLock;
     use std::time::Instant;
     use tokio::sync::mpsc::unbounded_channel;
 
diff --git a/codex-rs/tui/src/tui.rs b/codex-rs/tui/src/tui.rs
index d758996d..7787ed94 100644
--- a/codex-rs/tui/src/tui.rs
+++ b/codex-rs/tui/src/tui.rs
@@ -5,10 +5,11 @@ use std::io::Stdout;
 use std::io::stdout;
 use std::panic;
 use std::pin::Pin;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::atomic::AtomicBool;
 use std::sync::atomic::Ordering;
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 
 use crossterm::Command;
diff --git a/codex-rs/tui/src/tui/job_control.rs b/codex-rs/tui/src/tui/job_control.rs
index 36804194..c1aab718 100644
--- a/codex-rs/tui/src/tui/job_control.rs
+++ b/codex-rs/tui/src/tui/job_control.rs
@@ -1,6 +1,6 @@
 use std::io::Result;
 use std::io::stdout;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::Mutex;
 use std::sync::PoisonError;
 use std::sync::atomic::AtomicBool;
diff --git a/codex-rs/tui/src/updates.rs b/codex-rs/tui/src/updates.rs
index 0c3f2044..9655e2d8 100644
--- a/codex-rs/tui/src/updates.rs
+++ b/codex-rs/tui/src/updates.rs
@@ -10,7 +10,7 @@ use codex_core::default_client::create_client;
 use serde::Deserialize;
 use serde::Serialize;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::version::CODEX_CLI_VERSION;
 
diff --git a/codex-rs/utils/git/src/apply.rs b/codex-rs/utils/git/src/apply.rs
index c9e85032..5de7e2be 100644
--- a/codex-rs/utils/git/src/apply.rs
+++ b/codex-rs/utils/git/src/apply.rs
@@ -11,7 +11,7 @@ use regex::Regex;
 use std::ffi::OsStr;
 use std::io;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 /// Parameters for invoking [`apply_git_patch`].
 #[derive(Debug, Clone)]
diff --git a/codex-rs/utils/git/src/errors.rs b/codex-rs/utils/git/src/errors.rs
index 41f7b6df..226f4df1 100644
--- a/codex-rs/utils/git/src/errors.rs
+++ b/codex-rs/utils/git/src/errors.rs
@@ -1,4 +1,4 @@
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process::ExitStatus;
 use std::string::FromUtf8Error;
 
diff --git a/codex-rs/utils/git/src/ghost_commits.rs b/codex-rs/utils/git/src/ghost_commits.rs
index ec211ac3..bf1b48fc 100644
--- a/codex-rs/utils/git/src/ghost_commits.rs
+++ b/codex-rs/utils/git/src/ghost_commits.rs
@@ -3,7 +3,7 @@ use std::ffi::OsString;
 use std::fs;
 use std::io;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use tempfile::Builder;
 
diff --git a/codex-rs/utils/git/src/lib.rs b/codex-rs/utils/git/src/lib.rs
index cf2887aa..7e122237 100644
--- a/codex-rs/utils/git/src/lib.rs
+++ b/codex-rs/utils/git/src/lib.rs
@@ -1,5 +1,5 @@
 use std::fmt;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 mod apply;
 mod errors;
diff --git a/codex-rs/utils/git/src/operations.rs b/codex-rs/utils/git/src/operations.rs
index 415d63d5..0dd748fb 100644
--- a/codex-rs/utils/git/src/operations.rs
+++ b/codex-rs/utils/git/src/operations.rs
@@ -2,7 +2,7 @@ use std::ffi::OsStr;
 use std::ffi::OsString;
 use std::path::Component;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::process::Command;
 
 use crate::GitToolingError;
diff --git a/codex-rs/utils/image/src/error.rs b/codex-rs/utils/image/src/error.rs
index 6bd05511..2c51f5e5 100644
--- a/codex-rs/utils/image/src/error.rs
+++ b/codex-rs/utils/image/src/error.rs
@@ -1,6 +1,6 @@
 use image::ImageError;
 use image::ImageFormat;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use thiserror::Error;
 
 #[derive(Debug, Error)]
diff --git a/codex-rs/utils/pty/src/lib.rs b/codex-rs/utils/pty/src/lib.rs
index 14cc4307..eba1ec53 100644
--- a/codex-rs/utils/pty/src/lib.rs
+++ b/codex-rs/utils/pty/src/lib.rs
@@ -1,8 +1,59 @@
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::io::ErrorKind;
 use std::path::Path;
 use std::sync::atomic::AtomicBool;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 use std::sync::Mutex as StdMutex;
 use std::time::Duration;
 
diff --git a/codex-rs/utils/readiness/src/lib.rs b/codex-rs/utils/readiness/src/lib.rs
index 8b92f938..291723e1 100644
--- a/codex-rs/utils/readiness/src/lib.rs
+++ b/codex-rs/utils/readiness/src/lib.rs
@@ -198,7 +198,7 @@ mod errors {
 
 #[cfg(test)]
 mod tests {
-    use std::sync::Arc;
+    use std::sync::{Arc, OnceLock};
 
     use super::Readiness;
     use super::ReadinessFlag;
diff --git a/codex-rs/windows-sandbox-rs/src/allow.rs b/codex-rs/windows-sandbox-rs/src/allow.rs
index 01254fb5..0c9515bb 100644
--- a/codex-rs/windows-sandbox-rs/src/allow.rs
+++ b/codex-rs/windows-sandbox-rs/src/allow.rs
@@ -1,8 +1,59 @@
 use crate::policy::SandboxMode;
 use crate::policy::SandboxPolicy;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 pub fn compute_allow_paths(
     policy: &SandboxPolicy,
diff --git a/codex-rs/windows-sandbox-rs/src/audit.rs b/codex-rs/windows-sandbox-rs/src/audit.rs
index 4cd19dea..1f681056 100644
--- a/codex-rs/windows-sandbox-rs/src/audit.rs
+++ b/codex-rs/windows-sandbox-rs/src/audit.rs
@@ -4,8 +4,9 @@ use anyhow::Result;
 use std::collections::HashSet;
 use std::ffi::c_void;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::time::Duration;
+use std::sync::OnceLock;
 use std::time::Instant;
 use windows_sys::Win32::Foundation::LocalFree;
 use windows_sys::Win32::Foundation::ERROR_SUCCESS;
diff --git a/codex-rs/windows-sandbox-rs/src/cap.rs b/codex-rs/windows-sandbox-rs/src/cap.rs
index 2f4c9623..68254900 100644
--- a/codex-rs/windows-sandbox-rs/src/cap.rs
+++ b/codex-rs/windows-sandbox-rs/src/cap.rs
@@ -5,7 +5,7 @@ use serde::Deserialize;
 use serde::Serialize;
 use std::fs;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 #[derive(Serialize, Deserialize, Clone, Debug)]
 pub struct CapSids {
diff --git a/codex-rs/windows-sandbox-rs/src/env.rs b/codex-rs/windows-sandbox-rs/src/env.rs
index a8a3cda7..5a2113c8 100644
--- a/codex-rs/windows-sandbox-rs/src/env.rs
+++ b/codex-rs/windows-sandbox-rs/src/env.rs
@@ -1,11 +1,62 @@
 use anyhow::Result;
 use std::collections::HashMap;
 use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
+use std::env;
 use std::fs::File;
 use std::fs::{self};
 use std::io::Write;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 pub fn normalize_null_device_env(env_map: &mut HashMap<String, String>) {
     let keys: Vec<String> = env_map.keys().cloned().collect();
diff --git a/codex-rs/windows-sandbox-rs/src/lib.rs b/codex-rs/windows-sandbox-rs/src/lib.rs
index a2f63c8d..5931a84e 100644
--- a/codex-rs/windows-sandbox-rs/src/lib.rs
+++ b/codex-rs/windows-sandbox-rs/src/lib.rs
@@ -43,11 +43,62 @@ mod windows_impl {
     use super::winutil::to_wide;
     use anyhow::Result;
     use std::collections::HashMap;
+    use std::env;
+    use std::fs::OpenOptions;
+    use std::io::Write;
+    use serde_json::json;
+    use tracing::warn;
+    
+    static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+    
+    fn event_trace_path() -> Option<&'static PathBuf> {
+        EVENT_TRACE_PATH
+            .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                Some(path) if !path.is_empty() => {
+                    let file = PathBuf::from(path);
+                    if let Some(parent) = file.parent() {
+                        if let Err(err) = std::fs::create_dir_all(parent) {
+                            warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                            return None;
+                        }
+                    }
+                    Some(file)
+                }
+                _ => None,
+            })
+            .as_ref()
+    }
+    
+    fn log_event_for_hypebrut(event: &Event) {
+        let Some(path) = event_trace_path() else {
+            return;
+        };
+    
+        let timestamp = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_default()
+            .as_secs_f64();
+    
+        let payload = serde_json::json!({
+            \"ts\": timestamp,
+            \"event\": event,
+        });
+    
+        if let Err(err) = append_event_line(path, payload.to_string()) {
+            warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+        }
+    }
+    
+    fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+        let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+        file.write_all(line.as_bytes())?;
+        file.write_all(b\"\\n\")
+    }
     use std::ffi::c_void;
     use std::fs;
     use std::io;
     use std::path::Path;
-    use std::path::PathBuf;
+    use std::path::{Path, PathBuf};
     use std::ptr;
     use windows_sys::Win32::Foundation::CloseHandle;
     use windows_sys::Win32::Foundation::GetLastError;
@@ -426,6 +477,57 @@ mod stub {
     use anyhow::bail;
     use anyhow::Result;
     use std::collections::HashMap;
+    use std::env;
+    use std::fs::OpenOptions;
+    use std::io::Write;
+    use serde_json::json;
+    use tracing::warn;
+    
+    static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+    
+    fn event_trace_path() -> Option<&'static PathBuf> {
+        EVENT_TRACE_PATH
+            .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+                Some(path) if !path.is_empty() => {
+                    let file = PathBuf::from(path);
+                    if let Some(parent) = file.parent() {
+                        if let Err(err) = std::fs::create_dir_all(parent) {
+                            warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                            return None;
+                        }
+                    }
+                    Some(file)
+                }
+                _ => None,
+            })
+            .as_ref()
+    }
+    
+    fn log_event_for_hypebrut(event: &Event) {
+        let Some(path) = event_trace_path() else {
+            return;
+        };
+    
+        let timestamp = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_default()
+            .as_secs_f64();
+    
+        let payload = serde_json::json!({
+            \"ts\": timestamp,
+            \"event\": event,
+        });
+    
+        if let Err(err) = append_event_line(path, payload.to_string()) {
+            warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+        }
+    }
+    
+    fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+        let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+        file.write_all(line.as_bytes())?;
+        file.write_all(b\"\\n\")
+    }
     use std::path::Path;
 
     #[derive(Debug, Default)]
diff --git a/codex-rs/windows-sandbox-rs/src/logging.rs b/codex-rs/windows-sandbox-rs/src/logging.rs
index 9887ce81..9711607c 100644
--- a/codex-rs/windows-sandbox-rs/src/logging.rs
+++ b/codex-rs/windows-sandbox-rs/src/logging.rs
@@ -1,7 +1,7 @@
 use std::fs::OpenOptions;
 use std::io::Write;
 use std::path::Path;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 const LOG_COMMAND_PREVIEW_LIMIT: usize = 200;
 pub const LOG_FILE_NAME: &str = "sandbox_commands.rust.log";
diff --git a/codex-rs/windows-sandbox-rs/src/process.rs b/codex-rs/windows-sandbox-rs/src/process.rs
index 095dcf8b..9c24322b 100644
--- a/codex-rs/windows-sandbox-rs/src/process.rs
+++ b/codex-rs/windows-sandbox-rs/src/process.rs
@@ -4,6 +4,57 @@ use crate::winutil::to_wide;
 use anyhow::anyhow;
 use anyhow::Result;
 use std::collections::HashMap;
+use std::env;
+use std::fs::OpenOptions;
+use std::io::Write;
+use serde_json::json;
+use tracing::warn;
+
+static EVENT_TRACE_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();
+
+fn event_trace_path() -> Option<&'static PathBuf> {
+    EVENT_TRACE_PATH
+        .get_or_init(|| match env::var_os(\"HB_CODEX_EVENT_LOG\") {
+            Some(path) if !path.is_empty() => {
+                let file = PathBuf::from(path);
+                if let Some(parent) = file.parent() {
+                    if let Err(err) = std::fs::create_dir_all(parent) {
+                        warn!(?err, path = %parent.display(), \"failed to create HB_CODEX_EVENT_LOG parent\");
+                        return None;
+                    }
+                }
+                Some(file)
+            }
+            _ => None,
+        })
+        .as_ref()
+}
+
+fn log_event_for_hypebrut(event: &Event) {
+    let Some(path) = event_trace_path() else {
+        return;
+    };
+
+    let timestamp = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_secs_f64();
+
+    let payload = serde_json::json!({
+        \"ts\": timestamp,
+        \"event\": event,
+    });
+
+    if let Err(err) = append_event_line(path, payload.to_string()) {
+        warn!(?err, path = %path.display(), \"failed to append HB_CODEX_EVENT_LOG entry\");
+    }
+}
+
+fn append_event_line(path: &Path, line: String) -> std::io::Result<()> {
+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
+    file.write_all(line.as_bytes())?;
+    file.write_all(b\"\\n\")
+}
 use std::ffi::c_void;
 use std::path::Path;
 use windows_sys::Win32::Foundation::GetLastError;
